{"date":"Fri Jul 20 2018 10:18:13 GMT-0700 (PDT)","process":{"pid":68764,"uid":501,"gid":20,"cwd":"/Users/moshfeghhamedani/Desktop/Trash/vidly-api-node","execPath":"/usr/local/bin/node","version":"v8.9.1","argv":["/usr/local/bin/node","/Users/moshfeghhamedani/Desktop/Trash/vidly-api-node/index.js"],"memoryUsage":{"rss":59969536,"heapTotal":57044992,"heapUsed":20611200,"external":17867169}},"os":{"loadavg":[2.79296875,2.74169921875,2.95166015625],"uptime":575964},"trace":[{"column":11,"file":"/Users/moshfeghhamedani/Desktop/Trash/vidly-api-node/startup/config.js","function":"module.exports","line":5,"method":"exports","native":false},{"column":28,"file":"/Users/moshfeghhamedani/Desktop/Trash/vidly-api-node/index.js","function":null,"line":10,"method":null,"native":false},{"column":30,"file":"module.js","function":"Module._compile","line":635,"method":"_compile","native":false},{"column":10,"file":"module.js","function":"Module._extensions..js","line":646,"method":".js","native":false},{"column":32,"file":"module.js","function":"Module.load","line":554,"method":"load","native":false},{"column":12,"file":"module.js","function":"tryModuleLoad","line":497,"method":null,"native":false},{"column":3,"file":"module.js","function":"Module._load","line":489,"method":"_load","native":false},{"column":10,"file":"module.js","function":"Module.runMain","line":676,"method":"runMain","native":false},{"column":16,"file":"bootstrap_node.js","function":"startup","line":187,"method":null,"native":false},{"column":3,"file":"bootstrap_node.js","function":null,"line":608,"method":null,"native":false}],"stack":["Error: FATAL ERROR: jwtPrivateKey is not defined.","    at module.exports (/Users/moshfeghhamedani/Desktop/Trash/vidly-api-node/startup/config.js:5:11)","    at Object.<anonymous> (/Users/moshfeghhamedani/Desktop/Trash/vidly-api-node/index.js:10:28)","    at Module._compile (module.js:635:30)","    at Object.Module._extensions..js (module.js:646:10)","    at Module.load (module.js:554:32)","    at tryModuleLoad (module.js:497:12)","    at Function.Module._load (module.js:489:3)","    at Function.Module.runMain (module.js:676:10)","    at startup (bootstrap_node.js:187:16)","    at bootstrap_node.js:608:3"],"level":"error","message":"uncaughtException: FATAL ERROR: jwtPrivateKey is not defined.","timestamp":"2018-07-20T17:18:13.911Z"}
{"date":"Fri Apr 17 2020 23:34:01 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":5548,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":44920832,"heapTotal":28405760,"heapUsed":13265184,"external":19246093}},"os":{"loadavg":[0,0,0],"uptime":95875},"trace":[{"column":17,"file":"internal/modules/cjs/loader.js","function":"Module._resolveFilename","line":793,"method":"_resolveFilename","native":false},{"column":27,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":686,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","function":null,"line":2,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":15,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":6,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false}],"stack":["Error: Cannot find module 'bcrypt'","Require stack:","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:793:17)","    at Function.Module._load (internal/modules/cjs/loader.js:686:27)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js:2:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:6:15)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)"],"level":"error","message":"uncaughtException: Cannot find module 'bcrypt'\nRequire stack:\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","timestamp":"2020-04-17T13:34:01.797Z"}
{"date":"Fri Apr 17 2020 23:46:27 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":8568,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":45264896,"heapTotal":28667904,"heapUsed":12907344,"external":19114550}},"os":{"loadavg":[0,0,0],"uptime":96620},"trace":[{"column":17,"file":"internal/modules/cjs/loader.js","function":"Module._resolveFilename","line":793,"method":"_resolveFilename","native":false},{"column":27,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":686,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","function":null,"line":2,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":15,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":6,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false}],"stack":["Error: Cannot find module 'bcrypt'","Require stack:","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:793:17)","    at Function.Module._load (internal/modules/cjs/loader.js:686:27)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js:2:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:6:15)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)"],"level":"error","message":"uncaughtException: Cannot find module 'bcrypt'\nRequire stack:\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","timestamp":"2020-04-17T13:46:27.488Z"}
{"date":"Tue Apr 28 2020 23:42:36 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":1368,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":52076544,"heapTotal":30257152,"heapUsed":19283904,"external":20027312}},"os":{"loadavg":[0,0,0],"uptime":85447},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:42:36.493Z"}
{"date":"Tue Apr 28 2020 23:43:53 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":11016,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index"],"memoryUsage":{"rss":50446336,"heapTotal":31834112,"heapUsed":17930784,"external":19164860}},"os":{"loadavg":[0,0,0],"uptime":85524},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:43:53.504Z"}
{"date":"Tue Apr 28 2020 23:45:22 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":7424,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index"],"memoryUsage":{"rss":52723712,"heapTotal":29995008,"heapUsed":19664272,"external":20040121}},"os":{"loadavg":[0,0,0],"uptime":85614},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:45:22.861Z"}
{"date":"Tue Apr 28 2020 23:45:50 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":452,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index"],"memoryUsage":{"rss":50167808,"heapTotal":32096256,"heapUsed":18040448,"external":19164860}},"os":{"loadavg":[0,0,0],"uptime":85641},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:45:50.522Z"}
{"date":"Tue Apr 28 2020 23:47:45 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":4680,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":50368512,"heapTotal":32096256,"heapUsed":17917272,"external":19164860}},"os":{"loadavg":[0,0,0],"uptime":85756},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:47:45.213Z"}
{"date":"Tue Apr 28 2020 23:47:52 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":9128,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":50409472,"heapTotal":32096256,"heapUsed":17991144,"external":19164860}},"os":{"loadavg":[0,0,0],"uptime":85763},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:47:52.425Z"}
{"date":"Tue Apr 28 2020 23:49:04 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":532,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index"],"memoryUsage":{"rss":52957184,"heapTotal":30785536,"heapUsed":20030896,"external":20006355}},"os":{"loadavg":[0,0,0],"uptime":85836},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:49:04.897Z"}
{"date":"Tue Apr 28 2020 23:49:54 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":13992,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":52731904,"heapTotal":30257152,"heapUsed":19559040,"external":20040121}},"os":{"loadavg":[0,0,0],"uptime":85885},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:49:54.500Z"}
{"date":"Tue Apr 28 2020 23:50:05 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":14244,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":52793344,"heapTotal":30785536,"heapUsed":19997200,"external":20001188}},"os":{"loadavg":[0,0,0],"uptime":85896},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:50:05.110Z"}
{"date":"Tue Apr 28 2020 23:53:50 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":14220,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index"],"memoryUsage":{"rss":53211136,"heapTotal":29995008,"heapUsed":19673768,"external":20044332}},"os":{"loadavg":[0,0,0],"uptime":86121},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:53:50.398Z"}
{"date":"Tue Apr 28 2020 23:53:59 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":352,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":52969472,"heapTotal":29995008,"heapUsed":19688800,"external":20040121}},"os":{"loadavg":[0,0,0],"uptime":86130},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:53:59.600Z"}
{"date":"Tue Apr 28 2020 23:57:53 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":3196,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index"],"memoryUsage":{"rss":50401280,"heapTotal":32096256,"heapUsed":18067912,"external":19164860}},"os":{"loadavg":[0,0,0],"uptime":86364},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:57:54.116Z"}
{"date":"Tue Apr 28 2020 23:59:46 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":6316,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":52908032,"heapTotal":29995008,"heapUsed":19774576,"external":20040121}},"os":{"loadavg":[0,0,0],"uptime":86477},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T13:59:46.629Z"}
{"date":"Wed Apr 29 2020 00:12:34 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":7796,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":52830208,"heapTotal":29995008,"heapUsed":19689056,"external":20040121}},"os":{"loadavg":[0,0,0],"uptime":87245},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-28T14:12:34.318Z"}
{"date":"Wed Apr 29 2020 16:30:11 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":9384,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":39333888,"heapTotal":17936384,"heapUsed":13869288,"external":19156668}},"os":{"loadavg":[0,0,0],"uptime":145902},"trace":[{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":16,"file":"net.js","function":"TCPConnectWrap.afterConnect [as oncomplete]","line":1134,"method":"afterConnect [as oncomplete]","native":false},{"column":11,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js","function":null,"line":503,"method":null,"native":false},{"column":5,"file":"events.js","function":"Pool.emit","line":223,"method":"emit","native":false},{"column":12,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js","function":null,"line":326,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Connection.emit","line":223,"method":"emit","native":false},{"column":50,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js","function":null,"line":245,"method":null,"native":false},{"column":26,"file":"events.js","function":"Object.onceWrapper","line":313,"method":"onceWrapper","native":false},{"column":5,"file":"events.js","function":"Socket.emit","line":223,"method":"emit","native":false},{"column":8,"file":"internal/streams/destroy.js","function":"emitErrorNT","line":92,"method":null,"native":false},{"column":3,"file":"internal/streams/destroy.js","function":"emitErrorAndCloseNT","line":60,"method":null,"native":false},{"column":21,"file":"internal/process/task_queues.js","function":"processTicksAndRejections","line":81,"method":null,"native":false}],"stack":["MongoNetworkError: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017","    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {","  name: 'MongoNetworkError',","  message: 'connect ECONNREFUSED 127.0.0.1:27017',","  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +","    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'","}]","    at Pool.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\topologies\\server.js:503:11)","    at Pool.emit (events.js:223:5)","    at Connection.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\pool.js:326:12)","    at Object.onceWrapper (events.js:313:26)","    at Connection.emit (events.js:223:5)","    at Socket.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\mongodb-core\\lib\\connection\\connection.js:245:50)","    at Object.onceWrapper (events.js:313:26)","    at Socket.emit (events.js:223:5)","    at emitErrorNT (internal/streams/destroy.js:92:8)","    at emitErrorAndCloseNT (internal/streams/destroy.js:60:3)","    at processTicksAndRejections (internal/process/task_queues.js:81:21)"],"level":"error","message":"uncaughtException: failed to connect to server [localhost:27017] on first connect [Error: connect ECONNREFUSED 127.0.0.1:27017\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16) {\n  name: 'MongoNetworkError',\n  message: 'connect ECONNREFUSED 127.0.0.1:27017',\n  stack: 'Error: connect ECONNREFUSED 127.0.0.1:27017\\n' +\n    '    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1134:16)'\n}]","timestamp":"2020-04-29T06:30:11.589Z"}
{"date":"Fri May 01 2020 22:24:05 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":12872,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":43331584,"heapTotal":28667904,"heapUsed":16247904,"external":19602329}},"os":{"loadavg":[0,0,0],"uptime":624},"trace":[{"column":17,"file":"internal/modules/cjs/loader.js","function":"Module._resolveFilename","line":793,"method":"_resolveFilename","native":false},{"column":27,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":686,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","function":null,"line":2,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":15,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":6,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false}],"stack":["Error: Cannot find module 'bcrypt'","Require stack:","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:793:17)","    at Function.Module._load (internal/modules/cjs/loader.js:686:27)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js:2:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:6:15)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)"],"level":"error","message":"uncaughtException: Cannot find module 'bcrypt'\nRequire stack:\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","timestamp":"2020-05-01T12:24:05.686Z"}
{"date":"Fri May 01 2020 22:28:25 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":5256,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":45322240,"heapTotal":29192192,"heapUsed":13419576,"external":19246093}},"os":{"loadavg":[0,0,0],"uptime":883},"trace":[{"column":17,"file":"internal/modules/cjs/loader.js","function":"Module._resolveFilename","line":793,"method":"_resolveFilename","native":false},{"column":27,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":686,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","function":null,"line":2,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":15,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":6,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false}],"stack":["Error: Cannot find module 'bcrypt'","Require stack:","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:793:17)","    at Function.Module._load (internal/modules/cjs/loader.js:686:27)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js:2:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:6:15)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)"],"level":"error","message":"uncaughtException: Cannot find module 'bcrypt'\nRequire stack:\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","timestamp":"2020-05-01T12:28:25.099Z"}
{"date":"Fri May 01 2020 22:28:55 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":10748,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":43175936,"heapTotal":28667904,"heapUsed":16181944,"external":19602329}},"os":{"loadavg":[0,0,0],"uptime":913},"trace":[{"column":17,"file":"internal/modules/cjs/loader.js","function":"Module._resolveFilename","line":793,"method":"_resolveFilename","native":false},{"column":27,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":686,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","function":null,"line":2,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":15,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":6,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false}],"stack":["Error: Cannot find module 'bcrypt'","Require stack:","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:793:17)","    at Function.Module._load (internal/modules/cjs/loader.js:686:27)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js:2:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:6:15)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)"],"level":"error","message":"uncaughtException: Cannot find module 'bcrypt'\nRequire stack:\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","timestamp":"2020-05-01T12:28:55.152Z"}
{"date":"Fri May 01 2020 22:29:25 GMT+1000 (Australian Eastern Standard Time)","process":{"pid":10256,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js"],"memoryUsage":{"rss":45207552,"heapTotal":28930048,"heapUsed":13265088,"external":19114550}},"os":{"loadavg":[0,0,0],"uptime":944},"trace":[{"column":17,"file":"internal/modules/cjs/loader.js","function":"Module._resolveFilename","line":793,"method":"_resolveFilename","native":false},{"column":27,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":686,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","function":null,"line":2,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":15,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":6,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false}],"stack":["Error: Cannot find module 'bcrypt'","Require stack:","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:793:17)","    at Function.Module._load (internal/modules/cjs/loader.js:686:27)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js:2:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:6:15)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)"],"level":"error","message":"uncaughtException: Cannot find module 'bcrypt'\nRequire stack:\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\users.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js\n- C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","timestamp":"2020-05-01T12:29:25.926Z"}
{"date":"Thu Oct 22 2020 22:26:57 GMT+1100 (Australian Eastern Daylight Time)","process":{"pid":19152,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","index.js"],"memoryUsage":{"rss":54243328,"heapTotal":32284672,"heapUsed":16570888,"external":19662607}},"os":{"loadavg":[0,0,0],"uptime":295094},"trace":[{"column":20,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\models\\movie.js","function":null,"line":29,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":29,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\movies.js","function":null,"line":1,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":16,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js","function":null,"line":4,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false}],"stack":["ReferenceError: date is not defined","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\models\\movie.js:29:20)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\routes\\movies.js:1:29)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\startup\\routes.js:4:16)","    at Module._compile (internal/modules/cjs/loader.js:955:30)"],"level":"error","message":"uncaughtException: date is not defined","timestamp":"2020-10-22T11:26:58.545Z"}
{"date":"Thu Oct 22 2020 22:44:32 GMT+1100 (Australian Eastern Daylight Time)","process":{"pid":5996,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","index.js"],"memoryUsage":{"rss":57892864,"heapTotal":35090432,"heapUsed":22860480,"external":20043371}},"os":{"loadavg":[0,0,0],"uptime":296148},"trace":[{"column":null,"file":null,"function":null,"line":null,"method":null,"native":false},{"column":null,"file":null,"function":null,"line":null,"method":null,"native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":null,"line":null,"method":null,"native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":19,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\errors.js","function":"Object.exports.process","line":154,"method":"process","native":false},{"column":31,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\any.js","function":"internals.Array._validateWithOptions","line":607,"method":"_validateWithOptions","native":false},{"column":23,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.validate","line":121,"method":"validate","native":false},{"column":29,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.attempt","line":150,"method":"attempt","native":false},{"column":14,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.assert","line":145,"method":"assert","native":false},{"column":14,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.extend","line":203,"method":"extend","native":false},{"column":21,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\src\\index.js","function":null,"line":5,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":13,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\models\\movie.js","function":null,"line":1,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false}],"stack":["ValidationError: [","  {","    \"name\": \"date\",","    \"language\": {","      \"format\": \"must be a string with one of the following formats {{format}}\"","    },","    \"coerce\": \"[coerce(value, state, options) {\\n\\n        if (!value || value instanceof Date || typeof value === 'number') {\\n            return value;\\n        }\\n\\n        if (options.convert && this._flags.momentFormat) {\\n            const date = Moment(value, this._flags.momentFormat, true);\\n            if (date.isValid()) {\\n                return date.toDate();\\n            }\\n\\n            return this.createError('date.format', { value, format: this._flags.momentFormat }, state, options);\\n        }\\n\\n        return value;\\n    }]\",","    \"rules\": [","      {","        \"name\": \"format\",","        \"description\": \"[description(params) {\\n\\n                return `Date should respect format ${params.format}`;\\n            }]\",","        \"params\": {","          \"format\": {","            \"isJoi\": true,","            \"_currentJoi\": {","              \"isJoi\": true,","              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","              \"_type\": \"any\",","              \"_settings\": null,","              \"_valids\": {","                \"_set\": {},","                \"_hasRef\": false","              },","              \"_invalids\": {","                \"_set\": {},","                \"_hasRef\": false","              },","              \"_tests\": [],","              \"_refs\": [],","              \"_flags\": {},","              \"_description\": null,","              \"_unit\": null,","              \"_notes\": [],","              \"_tags\": [],","              \"_examples\": [],","              \"_meta\": [],","              \"_inner\": {},","              \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","              \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","              \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","              \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","              \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","              \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","              \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","              \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","              \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","              \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","              \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","              \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","              \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","              \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","              \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","              \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","              \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","              \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","              \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","              \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","              \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","              \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","              \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","              \"extensionSchema\": {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                \"_type\": \"object\",","                \"_settings\": {","                  \"convert\": false","                },","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {},","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": [","                    {","                      \"key\": \"base\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                            \"name\": \"type\",","                            \"arg\": {","                              \"name\": \"Joi object\",","                              \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                            }","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"name\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"string\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": 0","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {","                          \"presence\": \"required\"","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {}","                      }","                    },","                    {","                      \"key\": \"coerce\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                            \"name\": \"arity\",","                            \"arg\": 3","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {","                          \"func\": true","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"pre\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                            \"name\": \"arity\",","                            \"arg\": 3","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {","                          \"func\": true","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"language\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"describe\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                            \"name\": \"arity\",","                            \"arg\": 1","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {","                          \"func\": true","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"rules\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"array\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {","                          \"sparse\": false","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"items\": [","                            {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": [","                                  {","                                    \"key\": \"name\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"string\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": 0","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"presence\": \"required\"","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {}","                                    }","                                  },","                                  {","                                    \"key\": \"setup\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 1","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"validate\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 4","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"params\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": [","                                                  {","                                                    \"regex\": {},","                                                    \"rule\": {","                                                      \"isJoi\": true,","                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                                      \"_type\": \"object\",","                                                      \"_settings\": null,","                                                      \"_valids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_invalids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_tests\": [","                                                        {","                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                          \"name\": \"type\",","                                                          \"arg\": {","                                                            \"name\": \"Joi object\",","                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                          }","                                                        }","                                                      ],","                                                      \"_refs\": [],","                                                      \"_flags\": {},","                                                      \"_description\": null,","                                                      \"_unit\": null,","                                                      \"_notes\": [],","                                                      \"_tags\": [],","                                                      \"_examples\": [],","                                                      \"_meta\": [],","                                                      \"_inner\": {","                                                        \"children\": null,","                                                        \"renames\": [],","                                                        \"dependencies\": [],","                                                        \"patterns\": []","                                                      }","                                                    }","                                                  }","                                                ]","                                              }","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                  \"name\": \"type\",","                                                  \"arg\": {","                                                    \"name\": \"Joi object\",","                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                  }","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"description\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_type\": \"string\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": 0","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {},","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                  \"name\": \"arity\",","                                                  \"arg\": 1","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {","                                                \"func\": true","                                              },","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  }","                                ],","                                \"renames\": [],","                                \"dependencies\": [","                                  {","                                    \"type\": \"or\",","                                    \"key\": null,","                                    \"peers\": [","                                      \"setup\",","                                      \"validate\"","                                    ]","                                  }","                                ],","                                \"patterns\": []","                              }","                            }","                          ],","                          \"ordereds\": [],","                          \"inclusions\": [","                            {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": [","                                  {","                                    \"key\": \"name\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"string\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": 0","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"presence\": \"required\"","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {}","                                    }","                                  },","                                  {","                                    \"key\": \"setup\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 1","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"validate\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 4","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"params\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": [","                                                  {","                                                    \"regex\": {},","                                                    \"rule\": {","                                                      \"isJoi\": true,","                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                                      \"_type\": \"object\",","                                                      \"_settings\": null,","                                                      \"_valids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_invalids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_tests\": [","                                                        {","                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                          \"name\": \"type\",","                                                          \"arg\": {","                                                            \"name\": \"Joi object\",","                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                          }","                                                        }","                                                      ],","                                                      \"_refs\": [],","                                                      \"_flags\": {},","                                                      \"_description\": null,","                                                      \"_unit\": null,","                                                      \"_notes\": [],","                                                      \"_tags\": [],","                                                      \"_examples\": [],","                                                      \"_meta\": [],","                                                      \"_inner\": {","                                                        \"children\": null,","                                                        \"renames\": [],","                                                        \"dependencies\": [],","                                                        \"patterns\": []","                                                      }","                                                    }","                                                  }","                                                ]","                                              }","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                  \"name\": \"type\",","                                                  \"arg\": {","                                                    \"name\": \"Joi object\",","                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                  }","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"description\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_type\": \"string\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": 0","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {},","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                  \"name\": \"arity\",","                                                  \"arg\": 1","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {","                                                \"func\": true","                                              },","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  }","                                ],","                                \"renames\": [],","                                \"dependencies\": [","                                  {","                                    \"type\": \"or\",","                                    \"key\": null,","                                    \"peers\": [","                                      \"setup\",","                                      \"validate\"","                                    ]","                                  }","                                ],","                                \"patterns\": []","                              }","                            }","                          ],","                          \"exclusions\": [],","                          \"requireds\": []","                        }","                      }","                    }","                  ],","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              },","              \"extensionsSchema\": {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                \"_type\": \"array\",","                \"_settings\": {","                  \"convert\": false","                },","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {","                  \"sparse\": false","                },","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"items\": [","                    {","                      \"isJoi\": true,","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [","                        {","                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                          \"name\": \"arity\",","                          \"arg\": 1","                        }","                      ],","                      \"_refs\": [],","                      \"_flags\": {","                        \"func\": true","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    }","                  ],","                  \"ordereds\": [],","                  \"inclusions\": [","                    {","                      \"isJoi\": true,","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [","                        {","                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                          \"name\": \"arity\",","                          \"arg\": 1","                        }","                      ],","                      \"_refs\": [],","                      \"_flags\": {","                        \"func\": true","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    }","                  ],","                  \"exclusions\": [],","                  \"requireds\": []","                }","              },","              \"version\": \"13.4.0\"","            },","            \"_type\": \"array\",","            \"_settings\": null,","            \"_valids\": {","              \"_set\": {},","              \"_hasRef\": false","            },","            \"_invalids\": {","              \"_set\": {},","              \"_hasRef\": false","            },","            \"_tests\": [],","            \"_refs\": [],","            \"_flags\": {","              \"sparse\": false,","              \"single\": true,","              \"presence\": \"required\"","            },","            \"_description\": null,","            \"_unit\": null,","            \"_notes\": [],","            \"_tags\": [],","            \"_examples\": [],","            \"_meta\": [],","            \"_inner\": {","              \"items\": [","                {","                  \"isJoi\": true,","                  \"_type\": \"string\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": 0","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {},","                  \"_currentJoi\": {","                    \"isJoi\": true,","                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                    \"_type\": \"any\",","                    \"_settings\": null,","                    \"_valids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_invalids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_tests\": [],","                    \"_refs\": [],","                    \"_flags\": {},","                    \"_description\": null,","                    \"_unit\": null,","                    \"_notes\": [],","                    \"_tags\": [],","                    \"_examples\": [],","                    \"_meta\": [],","                    \"_inner\": {},","                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","                    \"extensionSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": [","                          {","                            \"key\": \"base\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                  \"name\": \"type\",","                                  \"arg\": {","                                    \"name\": \"Joi object\",","                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                  }","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"name\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"string\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": 0","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"presence\": \"required\"","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {}","                            }","                          },","                          {","                            \"key\": \"coerce\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"pre\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"language\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"describe\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 1","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"rules\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"array\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"sparse\": false","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"items\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"ordereds\": [],","                                \"inclusions\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"exclusions\": [],","                                \"requireds\": []","                              }","                            }","                          }","                        ],","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    \"extensionsSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                      \"_type\": \"array\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {","                        \"sparse\": false","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"items\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"ordereds\": [],","                        \"inclusions\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"exclusions\": [],","                        \"requireds\": []","                      }","                    },","                    \"version\": \"13.4.0\"","                  }","                }","              ],","              \"ordereds\": [],","              \"inclusions\": [","                {","                  \"isJoi\": true,","                  \"_type\": \"string\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": 0","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {},","                  \"_currentJoi\": {","                    \"isJoi\": true,","                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                    \"_type\": \"any\",","                    \"_settings\": null,","                    \"_valids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_invalids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_tests\": [],","                    \"_refs\": [],","                    \"_flags\": {},","                    \"_description\": null,","                    \"_unit\": null,","                    \"_notes\": [],","                    \"_tags\": [],","                    \"_examples\": [],","                    \"_meta\": [],","                    \"_inner\": {},","                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","                    \"extensionSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": [","                          {","                            \"key\": \"base\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                  \"name\": \"type\",","                                  \"arg\": {","                                    \"name\": \"Joi object\",","                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                  }","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"name\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"string\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": 0","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"presence\": \"required\"","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {}","                            }","                          },","                          {","                            \"key\": \"coerce\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"pre\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"language\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"describe\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 1","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"rules\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"array\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"sparse\": false","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"items\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"ordereds\": [],","                                \"inclusions\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"exclusions\": [],","                                \"requireds\": []","                              }","                            }","                          }","                        ],","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    \"extensionsSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                      \"_type\": \"array\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {","                        \"sparse\": false","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"items\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"ordereds\": [],","                        \"inclusions\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"exclusions\": [],","                        \"requireds\": []","                      }","                    },","                    \"version\": \"13.4.0\"","                  }","                }","              ],","              \"exclusions\": [],","              \"requireds\": []","            }","          }","        },","        \"setup\": \"[setup(params) {\\n\\n                this._flags.momentFormat = params.format;\\n            }]\",","        \"validate\": \"[validate(params, value, state, options) {\\n\\n                // No-op just to enable description\\n                return value;\\n            }]\"","      }","    ],","    \"base\" \u001b[31m[1]\u001b[0m: {","      \"isJoi\": true,","      \"_type\": \"date\",","      \"_settings\": null,","      \"_valids\": {","        \"_set\": {},","        \"_hasRef\": false","      },","      \"_invalids\": {","        \"_set\": {},","        \"_hasRef\": false","      },","      \"_tests\": [],","      \"_refs\": [],","      \"_flags\": {},","      \"_description\": null,","      \"_unit\": null,","      \"_notes\": [],","      \"_tags\": [],","      \"_examples\": [],","      \"_meta\": [],","      \"_inner\": {},","      \"_currentJoi\": {","        \"isJoi\": true,","        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","        \"_type\": \"any\",","        \"_settings\": null,","        \"_valids\": {","          \"_set\": {},","          \"_hasRef\": false","        },","        \"_invalids\": {","          \"_set\": {},","          \"_hasRef\": false","        },","        \"_tests\": [],","        \"_refs\": [],","        \"_flags\": {},","        \"_description\": null,","        \"_unit\": null,","        \"_notes\": [],","        \"_tags\": [],","        \"_examples\": [],","        \"_meta\": [],","        \"_inner\": {},","        \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","        \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","        \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","        \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","        \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","        \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","        \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","        \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","        \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","        \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","        \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","        \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","        \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","        \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","        \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","        \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","        \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","        \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","        \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","        \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","        \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","        \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","        \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","        \"extensionSchema\": {","          \"isJoi\": true,","          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","          \"_type\": \"object\",","          \"_settings\": {","            \"convert\": false","          },","          \"_valids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_invalids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_tests\": [],","          \"_refs\": [],","          \"_flags\": {},","          \"_description\": null,","          \"_unit\": null,","          \"_notes\": [],","          \"_tags\": [],","          \"_examples\": [],","          \"_meta\": [],","          \"_inner\": {","            \"children\": [","              {","                \"key\": \"base\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                      \"name\": \"type\",","                      \"arg\": {","                        \"name\": \"Joi object\",","                        \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                      }","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"name\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"string\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": 0","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {","                    \"presence\": \"required\"","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {}","                }","              },","              {","                \"key\": \"coerce\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                      \"name\": \"arity\",","                      \"arg\": 3","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {","                    \"func\": true","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"pre\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                      \"name\": \"arity\",","                      \"arg\": 3","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {","                    \"func\": true","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"language\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"describe\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                      \"name\": \"arity\",","                      \"arg\": 1","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {","                    \"func\": true","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"rules\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"array\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {","                    \"sparse\": false","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"items\": [","                      {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": [","                            {","                              \"key\": \"name\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"string\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": 0","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"presence\": \"required\"","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {}","                              }","                            },","                            {","                              \"key\": \"setup\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 1","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"validate\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 4","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"params\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": [","                                            {","                                              \"regex\": {},","                                              \"rule\": {","                                                \"isJoi\": true,","                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                                \"_type\": \"object\",","                                                \"_settings\": null,","                                                \"_valids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_invalids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_tests\": [","                                                  {","                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                    \"name\": \"type\",","                                                    \"arg\": {","                                                      \"name\": \"Joi object\",","                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                    }","                                                  }","                                                ],","                                                \"_refs\": [],","                                                \"_flags\": {},","                                                \"_description\": null,","                                                \"_unit\": null,","                                                \"_notes\": [],","                                                \"_tags\": [],","                                                \"_examples\": [],","                                                \"_meta\": [],","                                                \"_inner\": {","                                                  \"children\": null,","                                                  \"renames\": [],","                                                  \"dependencies\": [],","                                                  \"patterns\": []","                                                }","                                              }","                                            }","                                          ]","                                        }","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                            \"name\": \"type\",","                                            \"arg\": {","                                              \"name\": \"Joi object\",","                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                            }","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            },","                            {","                              \"key\": \"description\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_type\": \"string\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": 0","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {},","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                            \"name\": \"arity\",","                                            \"arg\": 1","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {","                                          \"func\": true","                                        },","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            }","                          ],","                          \"renames\": [],","                          \"dependencies\": [","                            {","                              \"type\": \"or\",","                              \"key\": null,","                              \"peers\": [","                                \"setup\",","                                \"validate\"","                              ]","                            }","                          ],","                          \"patterns\": []","                        }","                      }","                    ],","                    \"ordereds\": [],","                    \"inclusions\": [","                      {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": [","                            {","                              \"key\": \"name\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"string\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": 0","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"presence\": \"required\"","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {}","                              }","                            },","                            {","                              \"key\": \"setup\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 1","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"validate\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 4","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"params\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": [","                                            {","                                              \"regex\": {},","                                              \"rule\": {","                                                \"isJoi\": true,","                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                                \"_type\": \"object\",","                                                \"_settings\": null,","                                                \"_valids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_invalids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_tests\": [","                                                  {","                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                    \"name\": \"type\",","                                                    \"arg\": {","                                                      \"name\": \"Joi object\",","                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                    }","                                                  }","                                                ],","                                                \"_refs\": [],","                                                \"_flags\": {},","                                                \"_description\": null,","                                                \"_unit\": null,","                                                \"_notes\": [],","                                                \"_tags\": [],","                                                \"_examples\": [],","                                                \"_meta\": [],","                                                \"_inner\": {","                                                  \"children\": null,","                                                  \"renames\": [],","                                                  \"dependencies\": [],","                                                  \"patterns\": []","                                                }","                                              }","                                            }","                                          ]","                                        }","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                            \"name\": \"type\",","                                            \"arg\": {","                                              \"name\": \"Joi object\",","                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                            }","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            },","                            {","                              \"key\": \"description\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_type\": \"string\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": 0","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {},","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                            \"name\": \"arity\",","                                            \"arg\": 1","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {","                                          \"func\": true","                                        },","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            }","                          ],","                          \"renames\": [],","                          \"dependencies\": [","                            {","                              \"type\": \"or\",","                              \"key\": null,","                              \"peers\": [","                                \"setup\",","                                \"validate\"","                              ]","                            }","                          ],","                          \"patterns\": []","                        }","                      }","                    ],","                    \"exclusions\": [],","                    \"requireds\": []","                  }","                }","              }","            ],","            \"renames\": [],","            \"dependencies\": [],","            \"patterns\": []","          }","        },","        \"extensionsSchema\": {","          \"isJoi\": true,","          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","          \"_type\": \"array\",","          \"_settings\": {","            \"convert\": false","          },","          \"_valids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_invalids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_tests\": [],","          \"_refs\": [],","          \"_flags\": {","            \"sparse\": false","          },","          \"_description\": null,","          \"_unit\": null,","          \"_notes\": [],","          \"_tags\": [],","          \"_examples\": [],","          \"_meta\": [],","          \"_inner\": {","            \"items\": [","              {","                \"isJoi\": true,","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {},","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              },","              {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [","                  {","                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                    \"name\": \"arity\",","                    \"arg\": 1","                  }","                ],","                \"_refs\": [],","                \"_flags\": {","                  \"func\": true","                },","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              }","            ],","            \"ordereds\": [],","            \"inclusions\": [","              {","                \"isJoi\": true,","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {},","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              },","              {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [","                  {","                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                    \"name\": \"arity\",","                    \"arg\": 1","                  }","                ],","                \"_refs\": [],","                \"_flags\": {","                  \"func\": true","                },","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              }","            ],","            \"exclusions\": [],","            \"requireds\": []","          }","        },","        \"version\": \"13.4.0\"","      }","    }","  }","]","\u001b[31m","[1] \"base\" must be an instance of \"Joi object\"\u001b[0m","    at Object.exports.process (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\errors.js:154:19)","    at internals.Array._validateWithOptions (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\any.js:607:31)","    at module.exports.internals.Any.root.validate (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:121:23)","    at module.exports.internals.Any.root.attempt (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:150:29)","    at module.exports.internals.Any.root.assert (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:145:14)","    at module.exports.internals.Any.root.extend (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:203:14)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\src\\index.js:5:21)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\models\\movie.js:1:13)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)"],"level":"error","message":"uncaughtException: [\n  {\n    \"name\": \"date\",\n    \"language\": {\n      \"format\": \"must be a string with one of the following formats {{format}}\"\n    },\n    \"coerce\": \"[coerce(value, state, options) {\\n\\n        if (!value || value instanceof Date || typeof value === 'number') {\\n            return value;\\n        }\\n\\n        if (options.convert && this._flags.momentFormat) {\\n            const date = Moment(value, this._flags.momentFormat, true);\\n            if (date.isValid()) {\\n                return date.toDate();\\n            }\\n\\n            return this.createError('date.format', { value, format: this._flags.momentFormat }, state, options);\\n        }\\n\\n        return value;\\n    }]\",\n    \"rules\": [\n      {\n        \"name\": \"format\",\n        \"description\": \"[description(params) {\\n\\n                return `Date should respect format ${params.format}`;\\n            }]\",\n        \"params\": {\n          \"format\": {\n            \"isJoi\": true,\n            \"_currentJoi\": {\n              \"isJoi\": true,\n              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n              \"_type\": \"any\",\n              \"_settings\": null,\n              \"_valids\": {\n                \"_set\": {},\n                \"_hasRef\": false\n              },\n              \"_invalids\": {\n                \"_set\": {},\n                \"_hasRef\": false\n              },\n              \"_tests\": [],\n              \"_refs\": [],\n              \"_flags\": {},\n              \"_description\": null,\n              \"_unit\": null,\n              \"_notes\": [],\n              \"_tags\": [],\n              \"_examples\": [],\n              \"_meta\": [],\n              \"_inner\": {},\n              \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n              \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n              \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n              \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n              \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n              \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n              \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n              \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n              \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n              \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n              \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n              \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n              \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n              \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n              \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n              \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n              \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n              \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n              \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n              \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n              \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n              \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n              \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n              \"extensionSchema\": {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                \"_type\": \"object\",\n                \"_settings\": {\n                  \"convert\": false\n                },\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {},\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": [\n                    {\n                      \"key\": \"base\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                            \"name\": \"type\",\n                            \"arg\": {\n                              \"name\": \"Joi object\",\n                              \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                            }\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"name\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"string\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": 0\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"presence\": \"required\"\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {}\n                      }\n                    },\n                    {\n                      \"key\": \"coerce\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                            \"name\": \"arity\",\n                            \"arg\": 3\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"func\": true\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"pre\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                            \"name\": \"arity\",\n                            \"arg\": 3\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"func\": true\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"language\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"describe\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                            \"name\": \"arity\",\n                            \"arg\": 1\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"func\": true\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"rules\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"array\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"sparse\": false\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"items\": [\n                            {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": [\n                                  {\n                                    \"key\": \"name\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"string\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": 0\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"presence\": \"required\"\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {}\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"setup\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 1\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"validate\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 4\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"params\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": [\n                                                  {\n                                                    \"regex\": {},\n                                                    \"rule\": {\n                                                      \"isJoi\": true,\n                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                                      \"_type\": \"object\",\n                                                      \"_settings\": null,\n                                                      \"_valids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_invalids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_tests\": [\n                                                        {\n                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                          \"name\": \"type\",\n                                                          \"arg\": {\n                                                            \"name\": \"Joi object\",\n                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                          }\n                                                        }\n                                                      ],\n                                                      \"_refs\": [],\n                                                      \"_flags\": {},\n                                                      \"_description\": null,\n                                                      \"_unit\": null,\n                                                      \"_notes\": [],\n                                                      \"_tags\": [],\n                                                      \"_examples\": [],\n                                                      \"_meta\": [],\n                                                      \"_inner\": {\n                                                        \"children\": null,\n                                                        \"renames\": [],\n                                                        \"dependencies\": [],\n                                                        \"patterns\": []\n                                                      }\n                                                    }\n                                                  }\n                                                ]\n                                              }\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                  \"name\": \"type\",\n                                                  \"arg\": {\n                                                    \"name\": \"Joi object\",\n                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                  }\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"description\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_type\": \"string\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": 0\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {},\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                  \"name\": \"arity\",\n                                                  \"arg\": 1\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {\n                                                \"func\": true\n                                              },\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  }\n                                ],\n                                \"renames\": [],\n                                \"dependencies\": [\n                                  {\n                                    \"type\": \"or\",\n                                    \"key\": null,\n                                    \"peers\": [\n                                      \"setup\",\n                                      \"validate\"\n                                    ]\n                                  }\n                                ],\n                                \"patterns\": []\n                              }\n                            }\n                          ],\n                          \"ordereds\": [],\n                          \"inclusions\": [\n                            {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": [\n                                  {\n                                    \"key\": \"name\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"string\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": 0\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"presence\": \"required\"\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {}\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"setup\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 1\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"validate\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 4\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"params\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": [\n                                                  {\n                                                    \"regex\": {},\n                                                    \"rule\": {\n                                                      \"isJoi\": true,\n                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                                      \"_type\": \"object\",\n                                                      \"_settings\": null,\n                                                      \"_valids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_invalids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_tests\": [\n                                                        {\n                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                          \"name\": \"type\",\n                                                          \"arg\": {\n                                                            \"name\": \"Joi object\",\n                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                          }\n                                                        }\n                                                      ],\n                                                      \"_refs\": [],\n                                                      \"_flags\": {},\n                                                      \"_description\": null,\n                                                      \"_unit\": null,\n                                                      \"_notes\": [],\n                                                      \"_tags\": [],\n                                                      \"_examples\": [],\n                                                      \"_meta\": [],\n                                                      \"_inner\": {\n                                                        \"children\": null,\n                                                        \"renames\": [],\n                                                        \"dependencies\": [],\n                                                        \"patterns\": []\n                                                      }\n                                                    }\n                                                  }\n                                                ]\n                                              }\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                  \"name\": \"type\",\n                                                  \"arg\": {\n                                                    \"name\": \"Joi object\",\n                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                  }\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"description\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_type\": \"string\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": 0\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {},\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                  \"name\": \"arity\",\n                                                  \"arg\": 1\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {\n                                                \"func\": true\n                                              },\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  }\n                                ],\n                                \"renames\": [],\n                                \"dependencies\": [\n                                  {\n                                    \"type\": \"or\",\n                                    \"key\": null,\n                                    \"peers\": [\n                                      \"setup\",\n                                      \"validate\"\n                                    ]\n                                  }\n                                ],\n                                \"patterns\": []\n                              }\n                            }\n                          ],\n                          \"exclusions\": [],\n                          \"requireds\": []\n                        }\n                      }\n                    }\n                  ],\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              },\n              \"extensionsSchema\": {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                \"_type\": \"array\",\n                \"_settings\": {\n                  \"convert\": false\n                },\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {\n                  \"sparse\": false\n                },\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"items\": [\n                    {\n                      \"isJoi\": true,\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [\n                        {\n                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                          \"name\": \"arity\",\n                          \"arg\": 1\n                        }\n                      ],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"func\": true\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    }\n                  ],\n                  \"ordereds\": [],\n                  \"inclusions\": [\n                    {\n                      \"isJoi\": true,\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [\n                        {\n                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                          \"name\": \"arity\",\n                          \"arg\": 1\n                        }\n                      ],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"func\": true\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    }\n                  ],\n                  \"exclusions\": [],\n                  \"requireds\": []\n                }\n              },\n              \"version\": \"13.4.0\"\n            },\n            \"_type\": \"array\",\n            \"_settings\": null,\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false,\n              \"single\": true,\n              \"presence\": \"required\"\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"string\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": 0\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {},\n                  \"_currentJoi\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                    \"_type\": \"any\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {},\n                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n                    \"extensionSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": [\n                          {\n                            \"key\": \"base\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                  \"name\": \"type\",\n                                  \"arg\": {\n                                    \"name\": \"Joi object\",\n                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                  }\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"name\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"string\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": 0\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"presence\": \"required\"\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {}\n                            }\n                          },\n                          {\n                            \"key\": \"coerce\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"pre\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"language\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"describe\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 1\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"rules\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"array\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"sparse\": false\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"items\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"ordereds\": [],\n                                \"inclusions\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"exclusions\": [],\n                                \"requireds\": []\n                              }\n                            }\n                          }\n                        ],\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    \"extensionsSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                      \"_type\": \"array\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"sparse\": false\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"items\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"ordereds\": [],\n                        \"inclusions\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"exclusions\": [],\n                        \"requireds\": []\n                      }\n                    },\n                    \"version\": \"13.4.0\"\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"string\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": 0\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {},\n                  \"_currentJoi\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                    \"_type\": \"any\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {},\n                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n                    \"extensionSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": [\n                          {\n                            \"key\": \"base\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                  \"name\": \"type\",\n                                  \"arg\": {\n                                    \"name\": \"Joi object\",\n                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                  }\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"name\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"string\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": 0\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"presence\": \"required\"\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {}\n                            }\n                          },\n                          {\n                            \"key\": \"coerce\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"pre\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"language\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"describe\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 1\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"rules\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"array\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"sparse\": false\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"items\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"ordereds\": [],\n                                \"inclusions\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"exclusions\": [],\n                                \"requireds\": []\n                              }\n                            }\n                          }\n                        ],\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    \"extensionsSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                      \"_type\": \"array\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"sparse\": false\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"items\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"ordereds\": [],\n                        \"inclusions\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"exclusions\": [],\n                        \"requireds\": []\n                      }\n                    },\n                    \"version\": \"13.4.0\"\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          }\n        },\n        \"setup\": \"[setup(params) {\\n\\n                this._flags.momentFormat = params.format;\\n            }]\",\n        \"validate\": \"[validate(params, value, state, options) {\\n\\n                // No-op just to enable description\\n                return value;\\n            }]\"\n      }\n    ],\n    \"base\" \u001b[31m[1]\u001b[0m: {\n      \"isJoi\": true,\n      \"_type\": \"date\",\n      \"_settings\": null,\n      \"_valids\": {\n        \"_set\": {},\n        \"_hasRef\": false\n      },\n      \"_invalids\": {\n        \"_set\": {},\n        \"_hasRef\": false\n      },\n      \"_tests\": [],\n      \"_refs\": [],\n      \"_flags\": {},\n      \"_description\": null,\n      \"_unit\": null,\n      \"_notes\": [],\n      \"_tags\": [],\n      \"_examples\": [],\n      \"_meta\": [],\n      \"_inner\": {},\n      \"_currentJoi\": {\n        \"isJoi\": true,\n        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n        \"_type\": \"any\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_tests\": [],\n        \"_refs\": [],\n        \"_flags\": {},\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {},\n        \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n        \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n        \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n        \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n        \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n        \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n        \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n        \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n        \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n        \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n        \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n        \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n        \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n        \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n        \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n        \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n        \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n        \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n        \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n        \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n        \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n        \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n        \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n        \"extensionSchema\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n          \"_type\": \"object\",\n          \"_settings\": {\n            \"convert\": false\n          },\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {\n            \"children\": [\n              {\n                \"key\": \"base\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                      \"name\": \"type\",\n                      \"arg\": {\n                        \"name\": \"Joi object\",\n                        \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                      }\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"name\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"string\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": 0\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"presence\": \"required\"\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {}\n                }\n              },\n              {\n                \"key\": \"coerce\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 3\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"pre\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 3\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"language\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"describe\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"rules\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"array\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"sparse\": false\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"items\": [\n                      {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": [\n                            {\n                              \"key\": \"name\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"string\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": 0\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"presence\": \"required\"\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {}\n                              }\n                            },\n                            {\n                              \"key\": \"setup\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 1\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"validate\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 4\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"params\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": [\n                                            {\n                                              \"regex\": {},\n                                              \"rule\": {\n                                                \"isJoi\": true,\n                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                                \"_type\": \"object\",\n                                                \"_settings\": null,\n                                                \"_valids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_invalids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_tests\": [\n                                                  {\n                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                    \"name\": \"type\",\n                                                    \"arg\": {\n                                                      \"name\": \"Joi object\",\n                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                    }\n                                                  }\n                                                ],\n                                                \"_refs\": [],\n                                                \"_flags\": {},\n                                                \"_description\": null,\n                                                \"_unit\": null,\n                                                \"_notes\": [],\n                                                \"_tags\": [],\n                                                \"_examples\": [],\n                                                \"_meta\": [],\n                                                \"_inner\": {\n                                                  \"children\": null,\n                                                  \"renames\": [],\n                                                  \"dependencies\": [],\n                                                  \"patterns\": []\n                                                }\n                                              }\n                                            }\n                                          ]\n                                        }\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                            \"name\": \"type\",\n                                            \"arg\": {\n                                              \"name\": \"Joi object\",\n                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                            }\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"description\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_type\": \"string\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": 0\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {},\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                            \"name\": \"arity\",\n                                            \"arg\": 1\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {\n                                          \"func\": true\n                                        },\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            }\n                          ],\n                          \"renames\": [],\n                          \"dependencies\": [\n                            {\n                              \"type\": \"or\",\n                              \"key\": null,\n                              \"peers\": [\n                                \"setup\",\n                                \"validate\"\n                              ]\n                            }\n                          ],\n                          \"patterns\": []\n                        }\n                      }\n                    ],\n                    \"ordereds\": [],\n                    \"inclusions\": [\n                      {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": [\n                            {\n                              \"key\": \"name\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"string\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": 0\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"presence\": \"required\"\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {}\n                              }\n                            },\n                            {\n                              \"key\": \"setup\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 1\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"validate\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 4\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"params\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": [\n                                            {\n                                              \"regex\": {},\n                                              \"rule\": {\n                                                \"isJoi\": true,\n                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                                \"_type\": \"object\",\n                                                \"_settings\": null,\n                                                \"_valids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_invalids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_tests\": [\n                                                  {\n                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                    \"name\": \"type\",\n                                                    \"arg\": {\n                                                      \"name\": \"Joi object\",\n                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                    }\n                                                  }\n                                                ],\n                                                \"_refs\": [],\n                                                \"_flags\": {},\n                                                \"_description\": null,\n                                                \"_unit\": null,\n                                                \"_notes\": [],\n                                                \"_tags\": [],\n                                                \"_examples\": [],\n                                                \"_meta\": [],\n                                                \"_inner\": {\n                                                  \"children\": null,\n                                                  \"renames\": [],\n                                                  \"dependencies\": [],\n                                                  \"patterns\": []\n                                                }\n                                              }\n                                            }\n                                          ]\n                                        }\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                            \"name\": \"type\",\n                                            \"arg\": {\n                                              \"name\": \"Joi object\",\n                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                            }\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"description\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_type\": \"string\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": 0\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {},\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                            \"name\": \"arity\",\n                                            \"arg\": 1\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {\n                                          \"func\": true\n                                        },\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            }\n                          ],\n                          \"renames\": [],\n                          \"dependencies\": [\n                            {\n                              \"type\": \"or\",\n                              \"key\": null,\n                              \"peers\": [\n                                \"setup\",\n                                \"validate\"\n                              ]\n                            }\n                          ],\n                          \"patterns\": []\n                        }\n                      }\n                    ],\n                    \"exclusions\": [],\n                    \"requireds\": []\n                  }\n                }\n              }\n            ],\n            \"renames\": [],\n            \"dependencies\": [],\n            \"patterns\": []\n          }\n        },\n        \"extensionsSchema\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n          \"_type\": \"array\",\n          \"_settings\": {\n            \"convert\": false\n          },\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {\n            \"sparse\": false\n          },\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {\n            \"items\": [\n              {\n                \"isJoi\": true,\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {},\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              },\n              {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [\n                  {\n                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                    \"name\": \"arity\",\n                    \"arg\": 1\n                  }\n                ],\n                \"_refs\": [],\n                \"_flags\": {\n                  \"func\": true\n                },\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              }\n            ],\n            \"ordereds\": [],\n            \"inclusions\": [\n              {\n                \"isJoi\": true,\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {},\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              },\n              {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [\n                  {\n                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                    \"name\": \"arity\",\n                    \"arg\": 1\n                  }\n                ],\n                \"_refs\": [],\n                \"_flags\": {\n                  \"func\": true\n                },\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              }\n            ],\n            \"exclusions\": [],\n            \"requireds\": []\n          }\n        },\n        \"version\": \"13.4.0\"\n      }\n    }\n  }\n]\n\u001b[31m\n[1] \"base\" must be an instance of \"Joi object\"\u001b[0m","timestamp":"2020-10-22T11:44:48.669Z"}
{"date":"Thu Oct 22 2020 22:46:14 GMT+1100 (Australian Eastern Daylight Time)","process":{"pid":16108,"uid":null,"gid":null,"cwd":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node","execPath":"C:\\Program Files\\nodejs\\node.exe","version":"v12.14.1","argv":["C:\\Program Files\\nodejs\\node.exe","C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\index.js","index.js"],"memoryUsage":{"rss":57909248,"heapTotal":35090432,"heapUsed":22753448,"external":20035179}},"os":{"loadavg":[0,0,0],"uptime":296251},"trace":[{"column":null,"file":null,"function":null,"line":null,"method":null,"native":false},{"column":null,"file":null,"function":null,"line":null,"method":null,"native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":null,"line":null,"method":null,"native":false},{"column":null,"file":null,"function":"least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function","line":null,"method":"name] = function","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":null,"file":null,"function":"least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if","line":null,"method":"_getLabel();\\n        if","native":false},{"column":null,"file":null,"function":"least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if","line":null,"method":"_test('type', typeData, function (value, state, options) {\\n\\n            if","native":false},{"column":19,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\errors.js","function":"Object.exports.process","line":154,"method":"process","native":false},{"column":31,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\any.js","function":"internals.Array._validateWithOptions","line":607,"method":"_validateWithOptions","native":false},{"column":23,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.validate","line":121,"method":"validate","native":false},{"column":29,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.attempt","line":150,"method":"attempt","native":false},{"column":14,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.assert","line":145,"method":"assert","native":false},{"column":14,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js","function":"module.exports.internals.Any.root.extend","line":203,"method":"extend","native":false},{"column":21,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\src\\index.js","function":null,"line":5,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false},{"column":32,"file":"internal/modules/cjs/loader.js","function":"Module.load","line":811,"method":"load","native":false},{"column":14,"file":"internal/modules/cjs/loader.js","function":"Module._load","line":723,"method":"_load","native":false},{"column":19,"file":"internal/modules/cjs/loader.js","function":"Module.require","line":848,"method":"require","native":false},{"column":18,"file":"internal/modules/cjs/helpers.js","function":"require","line":74,"method":null,"native":false},{"column":13,"file":"C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\models\\movie.js","function":null,"line":1,"method":null,"native":false},{"column":30,"file":"internal/modules/cjs/loader.js","function":"Module._compile","line":955,"method":"_compile","native":false},{"column":10,"file":"internal/modules/cjs/loader.js","function":"Module._extensions..js","line":991,"method":".js","native":false}],"stack":["ValidationError: [","  {","    \"name\": \"date\",","    \"language\": {","      \"format\": \"must be a string with one of the following formats {{format}}\"","    },","    \"coerce\": \"[coerce(value, state, options) {\\n\\n        if (!value || value instanceof Date || typeof value === 'number') {\\n            return value;\\n        }\\n\\n        if (options.convert && this._flags.momentFormat) {\\n            const date = Moment(value, this._flags.momentFormat, true);\\n            if (date.isValid()) {\\n                return date.toDate();\\n            }\\n\\n            return this.createError('date.format', { value, format: this._flags.momentFormat }, state, options);\\n        }\\n\\n        return value;\\n    }]\",","    \"rules\": [","      {","        \"name\": \"format\",","        \"description\": \"[description(params) {\\n\\n                return `Date should respect format ${params.format}`;\\n            }]\",","        \"params\": {","          \"format\": {","            \"isJoi\": true,","            \"_currentJoi\": {","              \"isJoi\": true,","              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","              \"_type\": \"any\",","              \"_settings\": null,","              \"_valids\": {","                \"_set\": {},","                \"_hasRef\": false","              },","              \"_invalids\": {","                \"_set\": {},","                \"_hasRef\": false","              },","              \"_tests\": [],","              \"_refs\": [],","              \"_flags\": {},","              \"_description\": null,","              \"_unit\": null,","              \"_notes\": [],","              \"_tags\": [],","              \"_examples\": [],","              \"_meta\": [],","              \"_inner\": {},","              \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","              \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","              \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","              \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","              \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","              \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","              \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","              \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","              \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","              \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","              \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","              \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","              \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","              \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","              \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","              \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","              \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","              \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","              \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","              \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","              \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","              \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","              \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","              \"extensionSchema\": {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                \"_type\": \"object\",","                \"_settings\": {","                  \"convert\": false","                },","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {},","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": [","                    {","                      \"key\": \"base\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                            \"name\": \"type\",","                            \"arg\": {","                              \"name\": \"Joi object\",","                              \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                            }","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"name\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"string\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": 0","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {","                          \"presence\": \"required\"","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {}","                      }","                    },","                    {","                      \"key\": \"coerce\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                            \"name\": \"arity\",","                            \"arg\": 3","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {","                          \"func\": true","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"pre\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                            \"name\": \"arity\",","                            \"arg\": 3","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {","                          \"func\": true","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"language\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"describe\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [","                          {","                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                            \"name\": \"arity\",","                            \"arg\": 1","                          }","                        ],","                        \"_refs\": [],","                        \"_flags\": {","                          \"func\": true","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": null,","                          \"renames\": [],","                          \"dependencies\": [],","                          \"patterns\": []","                        }","                      }","                    },","                    {","                      \"key\": \"rules\",","                      \"schema\": {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                        \"_type\": \"array\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {","                          \"sparse\": false","                        },","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"items\": [","                            {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": [","                                  {","                                    \"key\": \"name\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"string\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": 0","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"presence\": \"required\"","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {}","                                    }","                                  },","                                  {","                                    \"key\": \"setup\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 1","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"validate\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 4","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"params\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": [","                                                  {","                                                    \"regex\": {},","                                                    \"rule\": {","                                                      \"isJoi\": true,","                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                                      \"_type\": \"object\",","                                                      \"_settings\": null,","                                                      \"_valids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_invalids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_tests\": [","                                                        {","                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                          \"name\": \"type\",","                                                          \"arg\": {","                                                            \"name\": \"Joi object\",","                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                          }","                                                        }","                                                      ],","                                                      \"_refs\": [],","                                                      \"_flags\": {},","                                                      \"_description\": null,","                                                      \"_unit\": null,","                                                      \"_notes\": [],","                                                      \"_tags\": [],","                                                      \"_examples\": [],","                                                      \"_meta\": [],","                                                      \"_inner\": {","                                                        \"children\": null,","                                                        \"renames\": [],","                                                        \"dependencies\": [],","                                                        \"patterns\": []","                                                      }","                                                    }","                                                  }","                                                ]","                                              }","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                  \"name\": \"type\",","                                                  \"arg\": {","                                                    \"name\": \"Joi object\",","                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                  }","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"description\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_type\": \"string\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": 0","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {},","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                  \"name\": \"arity\",","                                                  \"arg\": 1","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {","                                                \"func\": true","                                              },","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  }","                                ],","                                \"renames\": [],","                                \"dependencies\": [","                                  {","                                    \"type\": \"or\",","                                    \"key\": null,","                                    \"peers\": [","                                      \"setup\",","                                      \"validate\"","                                    ]","                                  }","                                ],","                                \"patterns\": []","                              }","                            }","                          ],","                          \"ordereds\": [],","                          \"inclusions\": [","                            {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": [","                                  {","                                    \"key\": \"name\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"string\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": 0","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"presence\": \"required\"","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {}","                                    }","                                  },","                                  {","                                    \"key\": \"setup\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 1","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"validate\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"object\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [","                                        {","                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                          \"name\": \"arity\",","                                          \"arg\": 4","                                        }","                                      ],","                                      \"_refs\": [],","                                      \"_flags\": {","                                        \"func\": true","                                      },","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"children\": null,","                                        \"renames\": [],","                                        \"dependencies\": [],","                                        \"patterns\": []","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"params\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": [","                                                  {","                                                    \"regex\": {},","                                                    \"rule\": {","                                                      \"isJoi\": true,","                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                                      \"_type\": \"object\",","                                                      \"_settings\": null,","                                                      \"_valids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_invalids\": {","                                                        \"_set\": {},","                                                        \"_hasRef\": false","                                                      },","                                                      \"_tests\": [","                                                        {","                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                          \"name\": \"type\",","                                                          \"arg\": {","                                                            \"name\": \"Joi object\",","                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                          }","                                                        }","                                                      ],","                                                      \"_refs\": [],","                                                      \"_flags\": {},","                                                      \"_description\": null,","                                                      \"_unit\": null,","                                                      \"_notes\": [],","                                                      \"_tags\": [],","                                                      \"_examples\": [],","                                                      \"_meta\": [],","                                                      \"_inner\": {","                                                        \"children\": null,","                                                        \"renames\": [],","                                                        \"dependencies\": [],","                                                        \"patterns\": []","                                                      }","                                                    }","                                                  }","                                                ]","                                              }","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                  \"name\": \"type\",","                                                  \"arg\": {","                                                    \"name\": \"Joi object\",","                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                  }","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  },","                                  {","                                    \"key\": \"description\",","                                    \"schema\": {","                                      \"isJoi\": true,","                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                      \"_type\": \"alternatives\",","                                      \"_settings\": null,","                                      \"_valids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_invalids\": {","                                        \"_set\": {},","                                        \"_hasRef\": false","                                      },","                                      \"_tests\": [],","                                      \"_refs\": [],","                                      \"_flags\": {},","                                      \"_description\": null,","                                      \"_unit\": null,","                                      \"_notes\": [],","                                      \"_tags\": [],","                                      \"_examples\": [],","                                      \"_meta\": [],","                                      \"_inner\": {","                                        \"matches\": [","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_type\": \"string\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": 0","                                              },","                                              \"_tests\": [],","                                              \"_refs\": [],","                                              \"_flags\": {},","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {},","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"","                                            }","                                          },","                                          {","                                            \"schema\": {","                                              \"isJoi\": true,","                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                                              \"_type\": \"object\",","                                              \"_settings\": null,","                                              \"_valids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_invalids\": {","                                                \"_set\": {},","                                                \"_hasRef\": false","                                              },","                                              \"_tests\": [","                                                {","                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                  \"name\": \"arity\",","                                                  \"arg\": 1","                                                }","                                              ],","                                              \"_refs\": [],","                                              \"_flags\": {","                                                \"func\": true","                                              },","                                              \"_description\": null,","                                              \"_unit\": null,","                                              \"_notes\": [],","                                              \"_tags\": [],","                                              \"_examples\": [],","                                              \"_meta\": [],","                                              \"_inner\": {","                                                \"children\": null,","                                                \"renames\": [],","                                                \"dependencies\": [],","                                                \"patterns\": []","                                              }","                                            }","                                          }","                                        ]","                                      }","                                    }","                                  }","                                ],","                                \"renames\": [],","                                \"dependencies\": [","                                  {","                                    \"type\": \"or\",","                                    \"key\": null,","                                    \"peers\": [","                                      \"setup\",","                                      \"validate\"","                                    ]","                                  }","                                ],","                                \"patterns\": []","                              }","                            }","                          ],","                          \"exclusions\": [],","                          \"requireds\": []","                        }","                      }","                    }","                  ],","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              },","              \"extensionsSchema\": {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                \"_type\": \"array\",","                \"_settings\": {","                  \"convert\": false","                },","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {","                  \"sparse\": false","                },","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"items\": [","                    {","                      \"isJoi\": true,","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [","                        {","                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                          \"name\": \"arity\",","                          \"arg\": 1","                        }","                      ],","                      \"_refs\": [],","                      \"_flags\": {","                        \"func\": true","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    }","                  ],","                  \"ordereds\": [],","                  \"inclusions\": [","                    {","                      \"isJoi\": true,","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": null,","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [","                        {","                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                          \"name\": \"arity\",","                          \"arg\": 1","                        }","                      ],","                      \"_refs\": [],","                      \"_flags\": {","                        \"func\": true","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": null,","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    }","                  ],","                  \"exclusions\": [],","                  \"requireds\": []","                }","              },","              \"version\": \"13.4.0\"","            },","            \"_type\": \"array\",","            \"_settings\": null,","            \"_valids\": {","              \"_set\": {},","              \"_hasRef\": false","            },","            \"_invalids\": {","              \"_set\": {},","              \"_hasRef\": false","            },","            \"_tests\": [],","            \"_refs\": [],","            \"_flags\": {","              \"sparse\": false,","              \"single\": true,","              \"presence\": \"required\"","            },","            \"_description\": null,","            \"_unit\": null,","            \"_notes\": [],","            \"_tags\": [],","            \"_examples\": [],","            \"_meta\": [],","            \"_inner\": {","              \"items\": [","                {","                  \"isJoi\": true,","                  \"_type\": \"string\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": 0","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {},","                  \"_currentJoi\": {","                    \"isJoi\": true,","                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                    \"_type\": \"any\",","                    \"_settings\": null,","                    \"_valids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_invalids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_tests\": [],","                    \"_refs\": [],","                    \"_flags\": {},","                    \"_description\": null,","                    \"_unit\": null,","                    \"_notes\": [],","                    \"_tags\": [],","                    \"_examples\": [],","                    \"_meta\": [],","                    \"_inner\": {},","                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","                    \"extensionSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": [","                          {","                            \"key\": \"base\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                  \"name\": \"type\",","                                  \"arg\": {","                                    \"name\": \"Joi object\",","                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                  }","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"name\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"string\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": 0","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"presence\": \"required\"","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {}","                            }","                          },","                          {","                            \"key\": \"coerce\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"pre\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"language\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"describe\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 1","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"rules\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                              \"_type\": \"array\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"sparse\": false","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"items\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"ordereds\": [],","                                \"inclusions\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"exclusions\": [],","                                \"requireds\": []","                              }","                            }","                          }","                        ],","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    \"extensionsSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                      \"_type\": \"array\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {","                        \"sparse\": false","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"items\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"ordereds\": [],","                        \"inclusions\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"exclusions\": [],","                        \"requireds\": []","                      }","                    },","                    \"version\": \"13.4.0\"","                  }","                }","              ],","              \"ordereds\": [],","              \"inclusions\": [","                {","                  \"isJoi\": true,","                  \"_type\": \"string\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": 0","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {},","                  \"_currentJoi\": {","                    \"isJoi\": true,","                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                    \"_type\": \"any\",","                    \"_settings\": null,","                    \"_valids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_invalids\": {","                      \"_set\": {},","                      \"_hasRef\": false","                    },","                    \"_tests\": [],","                    \"_refs\": [],","                    \"_flags\": {},","                    \"_description\": null,","                    \"_unit\": null,","                    \"_notes\": [],","                    \"_tags\": [],","                    \"_examples\": [],","                    \"_meta\": [],","                    \"_inner\": {},","                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","                    \"extensionSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                      \"_type\": \"object\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {},","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"children\": [","                          {","                            \"key\": \"base\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                  \"name\": \"type\",","                                  \"arg\": {","                                    \"name\": \"Joi object\",","                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                  }","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"name\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"string\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": 0","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"presence\": \"required\"","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {}","                            }","                          },","                          {","                            \"key\": \"coerce\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"pre\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 3","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"language\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {},","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"describe\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"object\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [","                                {","                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                  \"name\": \"arity\",","                                  \"arg\": 1","                                }","                              ],","                              \"_refs\": [],","                              \"_flags\": {","                                \"func\": true","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"children\": null,","                                \"renames\": [],","                                \"dependencies\": [],","                                \"patterns\": []","                              }","                            }","                          },","                          {","                            \"key\": \"rules\",","                            \"schema\": {","                              \"isJoi\": true,","                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                              \"_type\": \"array\",","                              \"_settings\": null,","                              \"_valids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_invalids\": {","                                \"_set\": {},","                                \"_hasRef\": false","                              },","                              \"_tests\": [],","                              \"_refs\": [],","                              \"_flags\": {","                                \"sparse\": false","                              },","                              \"_description\": null,","                              \"_unit\": null,","                              \"_notes\": [],","                              \"_tags\": [],","                              \"_examples\": [],","                              \"_meta\": [],","                              \"_inner\": {","                                \"items\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"ordereds\": [],","                                \"inclusions\": [","                                  {","                                    \"isJoi\": true,","                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                    \"_type\": \"object\",","                                    \"_settings\": null,","                                    \"_valids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_invalids\": {","                                      \"_set\": {},","                                      \"_hasRef\": false","                                    },","                                    \"_tests\": [],","                                    \"_refs\": [],","                                    \"_flags\": {},","                                    \"_description\": null,","                                    \"_unit\": null,","                                    \"_notes\": [],","                                    \"_tags\": [],","                                    \"_examples\": [],","                                    \"_meta\": [],","                                    \"_inner\": {","                                      \"children\": [","                                        {","                                          \"key\": \"name\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"string\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": 0","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"presence\": \"required\"","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {}","                                          }","                                        },","                                        {","                                          \"key\": \"setup\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 1","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"validate\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"object\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [","                                              {","                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                \"name\": \"arity\",","                                                \"arg\": 4","                                              }","                                            ],","                                            \"_refs\": [],","                                            \"_flags\": {","                                              \"func\": true","                                            },","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"children\": null,","                                              \"renames\": [],","                                              \"dependencies\": [],","                                              \"patterns\": []","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"params\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": [","                                                        {","                                                          \"regex\": {},","                                                          \"rule\": {","                                                            \"isJoi\": true,","                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                            \"_type\": \"object\",","                                                            \"_settings\": null,","                                                            \"_valids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_invalids\": {","                                                              \"_set\": {},","                                                              \"_hasRef\": false","                                                            },","                                                            \"_tests\": [","                                                              {","                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                                \"name\": \"type\",","                                                                \"arg\": {","                                                                  \"name\": \"Joi object\",","                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                                }","                                                              }","                                                            ],","                                                            \"_refs\": [],","                                                            \"_flags\": {},","                                                            \"_description\": null,","                                                            \"_unit\": null,","                                                            \"_notes\": [],","                                                            \"_tags\": [],","                                                            \"_examples\": [],","                                                            \"_meta\": [],","                                                            \"_inner\": {","                                                              \"children\": null,","                                                              \"renames\": [],","                                                              \"dependencies\": [],","                                                              \"patterns\": []","                                                            }","                                                          }","                                                        }","                                                      ]","                                                    }","                                                  }","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                        \"name\": \"type\",","                                                        \"arg\": {","                                                          \"name\": \"Joi object\",","                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                                        }","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {},","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        },","                                        {","                                          \"key\": \"description\",","                                          \"schema\": {","                                            \"isJoi\": true,","                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                            \"_type\": \"alternatives\",","                                            \"_settings\": null,","                                            \"_valids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_invalids\": {","                                              \"_set\": {},","                                              \"_hasRef\": false","                                            },","                                            \"_tests\": [],","                                            \"_refs\": [],","                                            \"_flags\": {},","                                            \"_description\": null,","                                            \"_unit\": null,","                                            \"_notes\": [],","                                            \"_tags\": [],","                                            \"_examples\": [],","                                            \"_meta\": [],","                                            \"_inner\": {","                                              \"matches\": [","                                                {","                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"","                                                },","                                                {","                                                  \"schema\": {","                                                    \"isJoi\": true,","                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                                                    \"_type\": \"object\",","                                                    \"_settings\": null,","                                                    \"_valids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_invalids\": {","                                                      \"_set\": {},","                                                      \"_hasRef\": false","                                                    },","                                                    \"_tests\": [","                                                      {","                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                                        \"name\": \"arity\",","                                                        \"arg\": 1","                                                      }","                                                    ],","                                                    \"_refs\": [],","                                                    \"_flags\": {","                                                      \"func\": true","                                                    },","                                                    \"_description\": null,","                                                    \"_unit\": null,","                                                    \"_notes\": [],","                                                    \"_tags\": [],","                                                    \"_examples\": [],","                                                    \"_meta\": [],","                                                    \"_inner\": {","                                                      \"children\": null,","                                                      \"renames\": [],","                                                      \"dependencies\": [],","                                                      \"patterns\": []","                                                    }","                                                  }","                                                }","                                              ]","                                            }","                                          }","                                        }","                                      ],","                                      \"renames\": [],","                                      \"dependencies\": [","                                        {","                                          \"type\": \"or\",","                                          \"key\": null,","                                          \"peers\": [","                                            \"setup\",","                                            \"validate\"","                                          ]","                                        }","                                      ],","                                      \"patterns\": []","                                    }","                                  }","                                ],","                                \"exclusions\": [],","                                \"requireds\": []","                              }","                            }","                          }","                        ],","                        \"renames\": [],","                        \"dependencies\": [],","                        \"patterns\": []","                      }","                    },","                    \"extensionsSchema\": {","                      \"isJoi\": true,","                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                      \"_type\": \"array\",","                      \"_settings\": {","                        \"convert\": false","                      },","                      \"_valids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_invalids\": {","                        \"_set\": {},","                        \"_hasRef\": false","                      },","                      \"_tests\": [],","                      \"_refs\": [],","                      \"_flags\": {","                        \"sparse\": false","                      },","                      \"_description\": null,","                      \"_unit\": null,","                      \"_notes\": [],","                      \"_tags\": [],","                      \"_examples\": [],","                      \"_meta\": [],","                      \"_inner\": {","                        \"items\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"ordereds\": [],","                        \"inclusions\": [","                          {","                            \"isJoi\": true,","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [],","                            \"_refs\": [],","                            \"_flags\": {},","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          },","                          {","                            \"isJoi\": true,","                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",","                            \"_type\": \"object\",","                            \"_settings\": null,","                            \"_valids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_invalids\": {","                              \"_set\": {},","                              \"_hasRef\": false","                            },","                            \"_tests\": [","                              {","                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                \"name\": \"arity\",","                                \"arg\": 1","                              }","                            ],","                            \"_refs\": [],","                            \"_flags\": {","                              \"func\": true","                            },","                            \"_description\": null,","                            \"_unit\": null,","                            \"_notes\": [],","                            \"_tags\": [],","                            \"_examples\": [],","                            \"_meta\": [],","                            \"_inner\": {","                              \"children\": null,","                              \"renames\": [],","                              \"dependencies\": [],","                              \"patterns\": []","                            }","                          }","                        ],","                        \"exclusions\": [],","                        \"requireds\": []","                      }","                    },","                    \"version\": \"13.4.0\"","                  }","                }","              ],","              \"exclusions\": [],","              \"requireds\": []","            }","          }","        },","        \"setup\": \"[setup(params) {\\n\\n                this._flags.momentFormat = params.format;\\n            }]\",","        \"validate\": \"[validate(params, value, state, options) {\\n\\n                // No-op just to enable description\\n                return value;\\n            }]\"","      }","    ],","    \"base\" \u001b[31m[1]\u001b[0m: {","      \"isJoi\": true,","      \"_type\": \"date\",","      \"_settings\": null,","      \"_valids\": {","        \"_set\": {},","        \"_hasRef\": false","      },","      \"_invalids\": {","        \"_set\": {},","        \"_hasRef\": false","      },","      \"_tests\": [],","      \"_refs\": [],","      \"_flags\": {},","      \"_description\": null,","      \"_unit\": null,","      \"_notes\": [],","      \"_tags\": [],","      \"_examples\": [],","      \"_meta\": [],","      \"_inner\": {},","      \"_currentJoi\": {","        \"isJoi\": true,","        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","        \"_type\": \"any\",","        \"_settings\": null,","        \"_valids\": {","          \"_set\": {},","          \"_hasRef\": false","        },","        \"_invalids\": {","          \"_set\": {},","          \"_hasRef\": false","        },","        \"_tests\": [],","        \"_refs\": [],","        \"_flags\": {},","        \"_description\": null,","        \"_unit\": null,","        \"_notes\": [],","        \"_tags\": [],","        \"_examples\": [],","        \"_meta\": [],","        \"_inner\": {},","        \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },","        \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","        \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },","        \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },","        \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","        \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },","        \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },","        \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },","        \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },","        \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },","        \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },","        \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },","        \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },","        \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },","        \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },","        \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },","        \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },","        \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },","        \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },","        \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },","        \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },","        \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },","        \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },","        \"extensionSchema\": {","          \"isJoi\": true,","          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","          \"_type\": \"object\",","          \"_settings\": {","            \"convert\": false","          },","          \"_valids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_invalids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_tests\": [],","          \"_refs\": [],","          \"_flags\": {},","          \"_description\": null,","          \"_unit\": null,","          \"_notes\": [],","          \"_tags\": [],","          \"_examples\": [],","          \"_meta\": [],","          \"_inner\": {","            \"children\": [","              {","                \"key\": \"base\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                      \"name\": \"type\",","                      \"arg\": {","                        \"name\": \"Joi object\",","                        \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                      }","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"name\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"string\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": 0","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {","                    \"presence\": \"required\"","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {}","                }","              },","              {","                \"key\": \"coerce\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                      \"name\": \"arity\",","                      \"arg\": 3","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {","                    \"func\": true","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"pre\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                      \"name\": \"arity\",","                      \"arg\": 3","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {","                    \"func\": true","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"language\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {},","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"describe\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"object\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [","                    {","                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                      \"name\": \"arity\",","                      \"arg\": 1","                    }","                  ],","                  \"_refs\": [],","                  \"_flags\": {","                    \"func\": true","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"children\": null,","                    \"renames\": [],","                    \"dependencies\": [],","                    \"patterns\": []","                  }","                }","              },","              {","                \"key\": \"rules\",","                \"schema\": {","                  \"isJoi\": true,","                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                  \"_type\": \"array\",","                  \"_settings\": null,","                  \"_valids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_invalids\": {","                    \"_set\": {},","                    \"_hasRef\": false","                  },","                  \"_tests\": [],","                  \"_refs\": [],","                  \"_flags\": {","                    \"sparse\": false","                  },","                  \"_description\": null,","                  \"_unit\": null,","                  \"_notes\": [],","                  \"_tags\": [],","                  \"_examples\": [],","                  \"_meta\": [],","                  \"_inner\": {","                    \"items\": [","                      {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": [","                            {","                              \"key\": \"name\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"string\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": 0","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"presence\": \"required\"","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {}","                              }","                            },","                            {","                              \"key\": \"setup\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 1","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"validate\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 4","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"params\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": [","                                            {","                                              \"regex\": {},","                                              \"rule\": {","                                                \"isJoi\": true,","                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                                \"_type\": \"object\",","                                                \"_settings\": null,","                                                \"_valids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_invalids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_tests\": [","                                                  {","                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                    \"name\": \"type\",","                                                    \"arg\": {","                                                      \"name\": \"Joi object\",","                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                    }","                                                  }","                                                ],","                                                \"_refs\": [],","                                                \"_flags\": {},","                                                \"_description\": null,","                                                \"_unit\": null,","                                                \"_notes\": [],","                                                \"_tags\": [],","                                                \"_examples\": [],","                                                \"_meta\": [],","                                                \"_inner\": {","                                                  \"children\": null,","                                                  \"renames\": [],","                                                  \"dependencies\": [],","                                                  \"patterns\": []","                                                }","                                              }","                                            }","                                          ]","                                        }","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                            \"name\": \"type\",","                                            \"arg\": {","                                              \"name\": \"Joi object\",","                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                            }","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            },","                            {","                              \"key\": \"description\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_type\": \"string\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": 0","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {},","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                            \"name\": \"arity\",","                                            \"arg\": 1","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {","                                          \"func\": true","                                        },","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            }","                          ],","                          \"renames\": [],","                          \"dependencies\": [","                            {","                              \"type\": \"or\",","                              \"key\": null,","                              \"peers\": [","                                \"setup\",","                                \"validate\"","                              ]","                            }","                          ],","                          \"patterns\": []","                        }","                      }","                    ],","                    \"ordereds\": [],","                    \"inclusions\": [","                      {","                        \"isJoi\": true,","                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                        \"_type\": \"object\",","                        \"_settings\": null,","                        \"_valids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_invalids\": {","                          \"_set\": {},","                          \"_hasRef\": false","                        },","                        \"_tests\": [],","                        \"_refs\": [],","                        \"_flags\": {},","                        \"_description\": null,","                        \"_unit\": null,","                        \"_notes\": [],","                        \"_tags\": [],","                        \"_examples\": [],","                        \"_meta\": [],","                        \"_inner\": {","                          \"children\": [","                            {","                              \"key\": \"name\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"string\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": 0","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"presence\": \"required\"","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {}","                              }","                            },","                            {","                              \"key\": \"setup\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 1","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"validate\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"object\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [","                                  {","                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                    \"name\": \"arity\",","                                    \"arg\": 4","                                  }","                                ],","                                \"_refs\": [],","                                \"_flags\": {","                                  \"func\": true","                                },","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"children\": null,","                                  \"renames\": [],","                                  \"dependencies\": [],","                                  \"patterns\": []","                                }","                              }","                            },","                            {","                              \"key\": \"params\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": [","                                            {","                                              \"regex\": {},","                                              \"rule\": {","                                                \"isJoi\": true,","                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                                \"_type\": \"object\",","                                                \"_settings\": null,","                                                \"_valids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_invalids\": {","                                                  \"_set\": {},","                                                  \"_hasRef\": false","                                                },","                                                \"_tests\": [","                                                  {","                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                                    \"name\": \"type\",","                                                    \"arg\": {","                                                      \"name\": \"Joi object\",","                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"","                                                    }","                                                  }","                                                ],","                                                \"_refs\": [],","                                                \"_flags\": {},","                                                \"_description\": null,","                                                \"_unit\": null,","                                                \"_notes\": [],","                                                \"_tags\": [],","                                                \"_examples\": [],","                                                \"_meta\": [],","                                                \"_inner\": {","                                                  \"children\": null,","                                                  \"renames\": [],","                                                  \"dependencies\": [],","                                                  \"patterns\": []","                                                }","                                              }","                                            }","                                          ]","                                        }","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },","                                            \"name\": \"type\",","                                            \"arg\": {","                                              \"name\": \"Joi object\",","                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"","                                            }","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            },","                            {","                              \"key\": \"description\",","                              \"schema\": {","                                \"isJoi\": true,","                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                \"_type\": \"alternatives\",","                                \"_settings\": null,","                                \"_valids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_invalids\": {","                                  \"_set\": {},","                                  \"_hasRef\": false","                                },","                                \"_tests\": [],","                                \"_refs\": [],","                                \"_flags\": {},","                                \"_description\": null,","                                \"_unit\": null,","                                \"_notes\": [],","                                \"_tags\": [],","                                \"_examples\": [],","                                \"_meta\": [],","                                \"_inner\": {","                                  \"matches\": [","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_type\": \"string\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": 0","                                        },","                                        \"_tests\": [],","                                        \"_refs\": [],","                                        \"_flags\": {},","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {},","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"","                                      }","                                    },","                                    {","                                      \"schema\": {","                                        \"isJoi\": true,","                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                                        \"_type\": \"object\",","                                        \"_settings\": null,","                                        \"_valids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_invalids\": {","                                          \"_set\": {},","                                          \"_hasRef\": false","                                        },","                                        \"_tests\": [","                                          {","                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                                            \"name\": \"arity\",","                                            \"arg\": 1","                                          }","                                        ],","                                        \"_refs\": [],","                                        \"_flags\": {","                                          \"func\": true","                                        },","                                        \"_description\": null,","                                        \"_unit\": null,","                                        \"_notes\": [],","                                        \"_tags\": [],","                                        \"_examples\": [],","                                        \"_meta\": [],","                                        \"_inner\": {","                                          \"children\": null,","                                          \"renames\": [],","                                          \"dependencies\": [],","                                          \"patterns\": []","                                        }","                                      }","                                    }","                                  ]","                                }","                              }","                            }","                          ],","                          \"renames\": [],","                          \"dependencies\": [","                            {","                              \"type\": \"or\",","                              \"key\": null,","                              \"peers\": [","                                \"setup\",","                                \"validate\"","                              ]","                            }","                          ],","                          \"patterns\": []","                        }","                      }","                    ],","                    \"exclusions\": [],","                    \"requireds\": []","                  }","                }","              }","            ],","            \"renames\": [],","            \"dependencies\": [],","            \"patterns\": []","          }","        },","        \"extensionsSchema\": {","          \"isJoi\": true,","          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","          \"_type\": \"array\",","          \"_settings\": {","            \"convert\": false","          },","          \"_valids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_invalids\": {","            \"_set\": {},","            \"_hasRef\": false","          },","          \"_tests\": [],","          \"_refs\": [],","          \"_flags\": {","            \"sparse\": false","          },","          \"_description\": null,","          \"_unit\": null,","          \"_notes\": [],","          \"_tags\": [],","          \"_examples\": [],","          \"_meta\": [],","          \"_inner\": {","            \"items\": [","              {","                \"isJoi\": true,","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {},","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              },","              {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [","                  {","                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                    \"name\": \"arity\",","                    \"arg\": 1","                  }","                ],","                \"_refs\": [],","                \"_flags\": {","                  \"func\": true","                },","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              }","            ],","            \"ordereds\": [],","            \"inclusions\": [","              {","                \"isJoi\": true,","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [],","                \"_refs\": [],","                \"_flags\": {},","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              },","              {","                \"isJoi\": true,","                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",","                \"_type\": \"object\",","                \"_settings\": null,","                \"_valids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_invalids\": {","                  \"_set\": {},","                  \"_hasRef\": false","                },","                \"_tests\": [","                  {","                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },","                    \"name\": \"arity\",","                    \"arg\": 1","                  }","                ],","                \"_refs\": [],","                \"_flags\": {","                  \"func\": true","                },","                \"_description\": null,","                \"_unit\": null,","                \"_notes\": [],","                \"_tags\": [],","                \"_examples\": [],","                \"_meta\": [],","                \"_inner\": {","                  \"children\": null,","                  \"renames\": [],","                  \"dependencies\": [],","                  \"patterns\": []","                }","              }","            ],","            \"exclusions\": [],","            \"requireds\": []","          }","        },","        \"version\": \"13.4.0\"","      }","    }","  }","]","\u001b[31m","[1] \"base\" must be an instance of \"Joi object\"\u001b[0m","    at Object.exports.process (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\errors.js:154:19)","    at internals.Array._validateWithOptions (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\any.js:607:31)","    at module.exports.internals.Any.root.validate (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:121:23)","    at module.exports.internals.Any.root.attempt (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:150:29)","    at module.exports.internals.Any.root.assert (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:145:14)","    at module.exports.internals.Any.root.extend (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\node_modules\\joi\\lib\\index.js:203:14)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\node_modules\\joi-full\\src\\index.js:5:21)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)","    at Module.load (internal/modules/cjs/loader.js:811:32)","    at Function.Module._load (internal/modules/cjs/loader.js:723:14)","    at Module.require (internal/modules/cjs/loader.js:848:19)","    at require (internal/modules/cjs/helpers.js:74:18)","    at Object.<anonymous> (C:\\Users\\Lo Yau Yat\\react-app\\vidly-api-node\\models\\movie.js:1:13)","    at Module._compile (internal/modules/cjs/loader.js:955:30)","    at Object.Module._extensions..js (internal/modules/cjs/loader.js:991:10)"],"level":"error","message":"uncaughtException: [\n  {\n    \"name\": \"date\",\n    \"language\": {\n      \"format\": \"must be a string with one of the following formats {{format}}\"\n    },\n    \"coerce\": \"[coerce(value, state, options) {\\n\\n        if (!value || value instanceof Date || typeof value === 'number') {\\n            return value;\\n        }\\n\\n        if (options.convert && this._flags.momentFormat) {\\n            const date = Moment(value, this._flags.momentFormat, true);\\n            if (date.isValid()) {\\n                return date.toDate();\\n            }\\n\\n            return this.createError('date.format', { value, format: this._flags.momentFormat }, state, options);\\n        }\\n\\n        return value;\\n    }]\",\n    \"rules\": [\n      {\n        \"name\": \"format\",\n        \"description\": \"[description(params) {\\n\\n                return `Date should respect format ${params.format}`;\\n            }]\",\n        \"params\": {\n          \"format\": {\n            \"isJoi\": true,\n            \"_currentJoi\": {\n              \"isJoi\": true,\n              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n              \"_type\": \"any\",\n              \"_settings\": null,\n              \"_valids\": {\n                \"_set\": {},\n                \"_hasRef\": false\n              },\n              \"_invalids\": {\n                \"_set\": {},\n                \"_hasRef\": false\n              },\n              \"_tests\": [],\n              \"_refs\": [],\n              \"_flags\": {},\n              \"_description\": null,\n              \"_unit\": null,\n              \"_notes\": [],\n              \"_tags\": [],\n              \"_examples\": [],\n              \"_meta\": [],\n              \"_inner\": {},\n              \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n              \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n              \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n              \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n              \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n              \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n              \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n              \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n              \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n              \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n              \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n              \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n              \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n              \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n              \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n              \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n              \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n              \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n              \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n              \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n              \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n              \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n              \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n              \"extensionSchema\": {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                \"_type\": \"object\",\n                \"_settings\": {\n                  \"convert\": false\n                },\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {},\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": [\n                    {\n                      \"key\": \"base\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                            \"name\": \"type\",\n                            \"arg\": {\n                              \"name\": \"Joi object\",\n                              \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                            }\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"name\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"string\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": 0\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"presence\": \"required\"\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {}\n                      }\n                    },\n                    {\n                      \"key\": \"coerce\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                            \"name\": \"arity\",\n                            \"arg\": 3\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"func\": true\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"pre\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                            \"name\": \"arity\",\n                            \"arg\": 3\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"func\": true\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"language\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"describe\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [\n                          {\n                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                            \"name\": \"arity\",\n                            \"arg\": 1\n                          }\n                        ],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"func\": true\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": null,\n                          \"renames\": [],\n                          \"dependencies\": [],\n                          \"patterns\": []\n                        }\n                      }\n                    },\n                    {\n                      \"key\": \"rules\",\n                      \"schema\": {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                        \"_type\": \"array\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {\n                          \"sparse\": false\n                        },\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"items\": [\n                            {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": [\n                                  {\n                                    \"key\": \"name\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"string\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": 0\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"presence\": \"required\"\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {}\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"setup\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 1\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"validate\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 4\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"params\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": [\n                                                  {\n                                                    \"regex\": {},\n                                                    \"rule\": {\n                                                      \"isJoi\": true,\n                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                                      \"_type\": \"object\",\n                                                      \"_settings\": null,\n                                                      \"_valids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_invalids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_tests\": [\n                                                        {\n                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                          \"name\": \"type\",\n                                                          \"arg\": {\n                                                            \"name\": \"Joi object\",\n                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                          }\n                                                        }\n                                                      ],\n                                                      \"_refs\": [],\n                                                      \"_flags\": {},\n                                                      \"_description\": null,\n                                                      \"_unit\": null,\n                                                      \"_notes\": [],\n                                                      \"_tags\": [],\n                                                      \"_examples\": [],\n                                                      \"_meta\": [],\n                                                      \"_inner\": {\n                                                        \"children\": null,\n                                                        \"renames\": [],\n                                                        \"dependencies\": [],\n                                                        \"patterns\": []\n                                                      }\n                                                    }\n                                                  }\n                                                ]\n                                              }\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                  \"name\": \"type\",\n                                                  \"arg\": {\n                                                    \"name\": \"Joi object\",\n                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                  }\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"description\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_type\": \"string\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": 0\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {},\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                  \"name\": \"arity\",\n                                                  \"arg\": 1\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {\n                                                \"func\": true\n                                              },\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  }\n                                ],\n                                \"renames\": [],\n                                \"dependencies\": [\n                                  {\n                                    \"type\": \"or\",\n                                    \"key\": null,\n                                    \"peers\": [\n                                      \"setup\",\n                                      \"validate\"\n                                    ]\n                                  }\n                                ],\n                                \"patterns\": []\n                              }\n                            }\n                          ],\n                          \"ordereds\": [],\n                          \"inclusions\": [\n                            {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": [\n                                  {\n                                    \"key\": \"name\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"string\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": 0\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"presence\": \"required\"\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {}\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"setup\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 1\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"validate\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"object\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [\n                                        {\n                                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                          \"name\": \"arity\",\n                                          \"arg\": 4\n                                        }\n                                      ],\n                                      \"_refs\": [],\n                                      \"_flags\": {\n                                        \"func\": true\n                                      },\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"children\": null,\n                                        \"renames\": [],\n                                        \"dependencies\": [],\n                                        \"patterns\": []\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"params\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": [\n                                                  {\n                                                    \"regex\": {},\n                                                    \"rule\": {\n                                                      \"isJoi\": true,\n                                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                                      \"_type\": \"object\",\n                                                      \"_settings\": null,\n                                                      \"_valids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_invalids\": {\n                                                        \"_set\": {},\n                                                        \"_hasRef\": false\n                                                      },\n                                                      \"_tests\": [\n                                                        {\n                                                          \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                          \"name\": \"type\",\n                                                          \"arg\": {\n                                                            \"name\": \"Joi object\",\n                                                            \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                          }\n                                                        }\n                                                      ],\n                                                      \"_refs\": [],\n                                                      \"_flags\": {},\n                                                      \"_description\": null,\n                                                      \"_unit\": null,\n                                                      \"_notes\": [],\n                                                      \"_tags\": [],\n                                                      \"_examples\": [],\n                                                      \"_meta\": [],\n                                                      \"_inner\": {\n                                                        \"children\": null,\n                                                        \"renames\": [],\n                                                        \"dependencies\": [],\n                                                        \"patterns\": []\n                                                      }\n                                                    }\n                                                  }\n                                                ]\n                                              }\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                  \"name\": \"type\",\n                                                  \"arg\": {\n                                                    \"name\": \"Joi object\",\n                                                    \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                  }\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  },\n                                  {\n                                    \"key\": \"description\",\n                                    \"schema\": {\n                                      \"isJoi\": true,\n                                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                      \"_type\": \"alternatives\",\n                                      \"_settings\": null,\n                                      \"_valids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_invalids\": {\n                                        \"_set\": {},\n                                        \"_hasRef\": false\n                                      },\n                                      \"_tests\": [],\n                                      \"_refs\": [],\n                                      \"_flags\": {},\n                                      \"_description\": null,\n                                      \"_unit\": null,\n                                      \"_notes\": [],\n                                      \"_tags\": [],\n                                      \"_examples\": [],\n                                      \"_meta\": [],\n                                      \"_inner\": {\n                                        \"matches\": [\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_type\": \"string\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": 0\n                                              },\n                                              \"_tests\": [],\n                                              \"_refs\": [],\n                                              \"_flags\": {},\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {},\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\"\n                                            }\n                                          },\n                                          {\n                                            \"schema\": {\n                                              \"isJoi\": true,\n                                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                                              \"_type\": \"object\",\n                                              \"_settings\": null,\n                                              \"_valids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_invalids\": {\n                                                \"_set\": {},\n                                                \"_hasRef\": false\n                                              },\n                                              \"_tests\": [\n                                                {\n                                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                  \"name\": \"arity\",\n                                                  \"arg\": 1\n                                                }\n                                              ],\n                                              \"_refs\": [],\n                                              \"_flags\": {\n                                                \"func\": true\n                                              },\n                                              \"_description\": null,\n                                              \"_unit\": null,\n                                              \"_notes\": [],\n                                              \"_tags\": [],\n                                              \"_examples\": [],\n                                              \"_meta\": [],\n                                              \"_inner\": {\n                                                \"children\": null,\n                                                \"renames\": [],\n                                                \"dependencies\": [],\n                                                \"patterns\": []\n                                              }\n                                            }\n                                          }\n                                        ]\n                                      }\n                                    }\n                                  }\n                                ],\n                                \"renames\": [],\n                                \"dependencies\": [\n                                  {\n                                    \"type\": \"or\",\n                                    \"key\": null,\n                                    \"peers\": [\n                                      \"setup\",\n                                      \"validate\"\n                                    ]\n                                  }\n                                ],\n                                \"patterns\": []\n                              }\n                            }\n                          ],\n                          \"exclusions\": [],\n                          \"requireds\": []\n                        }\n                      }\n                    }\n                  ],\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              },\n              \"extensionsSchema\": {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                \"_type\": \"array\",\n                \"_settings\": {\n                  \"convert\": false\n                },\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {\n                  \"sparse\": false\n                },\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"items\": [\n                    {\n                      \"isJoi\": true,\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [\n                        {\n                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                          \"name\": \"arity\",\n                          \"arg\": 1\n                        }\n                      ],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"func\": true\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    }\n                  ],\n                  \"ordereds\": [],\n                  \"inclusions\": [\n                    {\n                      \"isJoi\": true,\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": null,\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [\n                        {\n                          \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                          \"name\": \"arity\",\n                          \"arg\": 1\n                        }\n                      ],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"func\": true\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": null,\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    }\n                  ],\n                  \"exclusions\": [],\n                  \"requireds\": []\n                }\n              },\n              \"version\": \"13.4.0\"\n            },\n            \"_type\": \"array\",\n            \"_settings\": null,\n            \"_valids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_invalids\": {\n              \"_set\": {},\n              \"_hasRef\": false\n            },\n            \"_tests\": [],\n            \"_refs\": [],\n            \"_flags\": {\n              \"sparse\": false,\n              \"single\": true,\n              \"presence\": \"required\"\n            },\n            \"_description\": null,\n            \"_unit\": null,\n            \"_notes\": [],\n            \"_tags\": [],\n            \"_examples\": [],\n            \"_meta\": [],\n            \"_inner\": {\n              \"items\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"string\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": 0\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {},\n                  \"_currentJoi\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                    \"_type\": \"any\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {},\n                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n                    \"extensionSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": [\n                          {\n                            \"key\": \"base\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                  \"name\": \"type\",\n                                  \"arg\": {\n                                    \"name\": \"Joi object\",\n                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                  }\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"name\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"string\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": 0\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"presence\": \"required\"\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {}\n                            }\n                          },\n                          {\n                            \"key\": \"coerce\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"pre\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"language\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"describe\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 1\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"rules\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                              \"_type\": \"array\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"sparse\": false\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"items\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"ordereds\": [],\n                                \"inclusions\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.items.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"exclusions\": [],\n                                \"requireds\": []\n                              }\n                            }\n                          }\n                        ],\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    \"extensionsSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                      \"_type\": \"array\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"sparse\": false\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"items\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"ordereds\": [],\n                        \"inclusions\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.items.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"exclusions\": [],\n                        \"requireds\": []\n                      }\n                    },\n                    \"version\": \"13.4.0\"\n                  }\n                }\n              ],\n              \"ordereds\": [],\n              \"inclusions\": [\n                {\n                  \"isJoi\": true,\n                  \"_type\": \"string\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": 0\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {},\n                  \"_currentJoi\": {\n                    \"isJoi\": true,\n                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                    \"_type\": \"any\",\n                    \"_settings\": null,\n                    \"_valids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_invalids\": {\n                      \"_set\": {},\n                      \"_hasRef\": false\n                    },\n                    \"_tests\": [],\n                    \"_refs\": [],\n                    \"_flags\": {},\n                    \"_description\": null,\n                    \"_unit\": null,\n                    \"_notes\": [],\n                    \"_tags\": [],\n                    \"_examples\": [],\n                    \"_meta\": [],\n                    \"_inner\": {},\n                    \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n                    \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n                    \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n                    \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n                    \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n                    \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n                    \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n                    \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n                    \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n                    \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n                    \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n                    \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n                    \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n                    \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n                    \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n                    \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n                    \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n                    \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n                    \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n                    \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n                    \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n                    \"extensionSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                      \"_type\": \"object\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {},\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"children\": [\n                          {\n                            \"key\": \"base\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                  \"name\": \"type\",\n                                  \"arg\": {\n                                    \"name\": \"Joi object\",\n                                    \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                  }\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"name\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"string\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": 0\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"presence\": \"required\"\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {}\n                            }\n                          },\n                          {\n                            \"key\": \"coerce\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"pre\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 3\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"language\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {},\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"describe\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"object\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [\n                                {\n                                  \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                  \"name\": \"arity\",\n                                  \"arg\": 1\n                                }\n                              ],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"func\": true\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"children\": null,\n                                \"renames\": [],\n                                \"dependencies\": [],\n                                \"patterns\": []\n                              }\n                            }\n                          },\n                          {\n                            \"key\": \"rules\",\n                            \"schema\": {\n                              \"isJoi\": true,\n                              \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                              \"_type\": \"array\",\n                              \"_settings\": null,\n                              \"_valids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_invalids\": {\n                                \"_set\": {},\n                                \"_hasRef\": false\n                              },\n                              \"_tests\": [],\n                              \"_refs\": [],\n                              \"_flags\": {\n                                \"sparse\": false\n                              },\n                              \"_description\": null,\n                              \"_unit\": null,\n                              \"_notes\": [],\n                              \"_tags\": [],\n                              \"_examples\": [],\n                              \"_meta\": [],\n                              \"_inner\": {\n                                \"items\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"ordereds\": [],\n                                \"inclusions\": [\n                                  {\n                                    \"isJoi\": true,\n                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                    \"_type\": \"object\",\n                                    \"_settings\": null,\n                                    \"_valids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_invalids\": {\n                                      \"_set\": {},\n                                      \"_hasRef\": false\n                                    },\n                                    \"_tests\": [],\n                                    \"_refs\": [],\n                                    \"_flags\": {},\n                                    \"_description\": null,\n                                    \"_unit\": null,\n                                    \"_notes\": [],\n                                    \"_tags\": [],\n                                    \"_examples\": [],\n                                    \"_meta\": [],\n                                    \"_inner\": {\n                                      \"children\": [\n                                        {\n                                          \"key\": \"name\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"string\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": 0\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"presence\": \"required\"\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {}\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"setup\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 1\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"validate\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"object\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [\n                                              {\n                                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                \"name\": \"arity\",\n                                                \"arg\": 4\n                                              }\n                                            ],\n                                            \"_refs\": [],\n                                            \"_flags\": {\n                                              \"func\": true\n                                            },\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"children\": null,\n                                              \"renames\": [],\n                                              \"dependencies\": [],\n                                              \"patterns\": []\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"params\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": [\n                                                        {\n                                                          \"regex\": {},\n                                                          \"rule\": {\n                                                            \"isJoi\": true,\n                                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                            \"_type\": \"object\",\n                                                            \"_settings\": null,\n                                                            \"_valids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_invalids\": {\n                                                              \"_set\": {},\n                                                              \"_hasRef\": false\n                                                            },\n                                                            \"_tests\": [\n                                                              {\n                                                                \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                                \"name\": \"type\",\n                                                                \"arg\": {\n                                                                  \"name\": \"Joi object\",\n                                                                  \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                                }\n                                                              }\n                                                            ],\n                                                            \"_refs\": [],\n                                                            \"_flags\": {},\n                                                            \"_description\": null,\n                                                            \"_unit\": null,\n                                                            \"_notes\": [],\n                                                            \"_tags\": [],\n                                                            \"_examples\": [],\n                                                            \"_meta\": [],\n                                                            \"_inner\": {\n                                                              \"children\": null,\n                                                              \"renames\": [],\n                                                              \"dependencies\": [],\n                                                              \"patterns\": []\n                                                            }\n                                                          }\n                                                        }\n                                                      ]\n                                                    }\n                                                  }\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                        \"name\": \"type\",\n                                                        \"arg\": {\n                                                          \"name\": \"Joi object\",\n                                                          \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                                        }\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {},\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        },\n                                        {\n                                          \"key\": \"description\",\n                                          \"schema\": {\n                                            \"isJoi\": true,\n                                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                            \"_type\": \"alternatives\",\n                                            \"_settings\": null,\n                                            \"_valids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_invalids\": {\n                                              \"_set\": {},\n                                              \"_hasRef\": false\n                                            },\n                                            \"_tests\": [],\n                                            \"_refs\": [],\n                                            \"_flags\": {},\n                                            \"_description\": null,\n                                            \"_unit\": null,\n                                            \"_notes\": [],\n                                            \"_tags\": [],\n                                            \"_examples\": [],\n                                            \"_meta\": [],\n                                            \"_inner\": {\n                                              \"matches\": [\n                                                {\n                                                  \"schema\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0]\"\n                                                },\n                                                {\n                                                  \"schema\": {\n                                                    \"isJoi\": true,\n                                                    \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                                                    \"_type\": \"object\",\n                                                    \"_settings\": null,\n                                                    \"_valids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_invalids\": {\n                                                      \"_set\": {},\n                                                      \"_hasRef\": false\n                                                    },\n                                                    \"_tests\": [\n                                                      {\n                                                        \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                                        \"name\": \"arity\",\n                                                        \"arg\": 1\n                                                      }\n                                                    ],\n                                                    \"_refs\": [],\n                                                    \"_flags\": {\n                                                      \"func\": true\n                                                    },\n                                                    \"_description\": null,\n                                                    \"_unit\": null,\n                                                    \"_notes\": [],\n                                                    \"_tags\": [],\n                                                    \"_examples\": [],\n                                                    \"_meta\": [],\n                                                    \"_inner\": {\n                                                      \"children\": null,\n                                                      \"renames\": [],\n                                                      \"dependencies\": [],\n                                                      \"patterns\": []\n                                                    }\n                                                  }\n                                                }\n                                              ]\n                                            }\n                                          }\n                                        }\n                                      ],\n                                      \"renames\": [],\n                                      \"dependencies\": [\n                                        {\n                                          \"type\": \"or\",\n                                          \"key\": null,\n                                          \"peers\": [\n                                            \"setup\",\n                                            \"validate\"\n                                          ]\n                                        }\n                                      ],\n                                      \"patterns\": []\n                                    }\n                                  }\n                                ],\n                                \"exclusions\": [],\n                                \"requireds\": []\n                              }\n                            }\n                          }\n                        ],\n                        \"renames\": [],\n                        \"dependencies\": [],\n                        \"patterns\": []\n                      }\n                    },\n                    \"extensionsSchema\": {\n                      \"isJoi\": true,\n                      \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                      \"_type\": \"array\",\n                      \"_settings\": {\n                        \"convert\": false\n                      },\n                      \"_valids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_invalids\": {\n                        \"_set\": {},\n                        \"_hasRef\": false\n                      },\n                      \"_tests\": [],\n                      \"_refs\": [],\n                      \"_flags\": {\n                        \"sparse\": false\n                      },\n                      \"_description\": null,\n                      \"_unit\": null,\n                      \"_notes\": [],\n                      \"_tags\": [],\n                      \"_examples\": [],\n                      \"_meta\": [],\n                      \"_inner\": {\n                        \"items\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"ordereds\": [],\n                        \"inclusions\": [\n                          {\n                            \"isJoi\": true,\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [],\n                            \"_refs\": [],\n                            \"_flags\": {},\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          },\n                          {\n                            \"isJoi\": true,\n                            \"_currentJoi\": \"[Circular ~.0.rules.0.params.format._inner.inclusions.0._currentJoi]\",\n                            \"_type\": \"object\",\n                            \"_settings\": null,\n                            \"_valids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_invalids\": {\n                              \"_set\": {},\n                              \"_hasRef\": false\n                            },\n                            \"_tests\": [\n                              {\n                                \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                \"name\": \"arity\",\n                                \"arg\": 1\n                              }\n                            ],\n                            \"_refs\": [],\n                            \"_flags\": {\n                              \"func\": true\n                            },\n                            \"_description\": null,\n                            \"_unit\": null,\n                            \"_notes\": [],\n                            \"_tags\": [],\n                            \"_examples\": [],\n                            \"_meta\": [],\n                            \"_inner\": {\n                              \"children\": null,\n                              \"renames\": [],\n                              \"dependencies\": [],\n                              \"patterns\": []\n                            }\n                          }\n                        ],\n                        \"exclusions\": [],\n                        \"requireds\": []\n                      }\n                    },\n                    \"version\": \"13.4.0\"\n                  }\n                }\n              ],\n              \"exclusions\": [],\n              \"requireds\": []\n            }\n          }\n        },\n        \"setup\": \"[setup(params) {\\n\\n                this._flags.momentFormat = params.format;\\n            }]\",\n        \"validate\": \"[validate(params, value, state, options) {\\n\\n                // No-op just to enable description\\n                return value;\\n            }]\"\n      }\n    ],\n    \"base\" \u001b[31m[1]\u001b[0m: {\n      \"isJoi\": true,\n      \"_type\": \"date\",\n      \"_settings\": null,\n      \"_valids\": {\n        \"_set\": {},\n        \"_hasRef\": false\n      },\n      \"_invalids\": {\n        \"_set\": {},\n        \"_hasRef\": false\n      },\n      \"_tests\": [],\n      \"_refs\": [],\n      \"_flags\": {},\n      \"_description\": null,\n      \"_unit\": null,\n      \"_notes\": [],\n      \"_tags\": [],\n      \"_examples\": [],\n      \"_meta\": [],\n      \"_inner\": {},\n      \"_currentJoi\": {\n        \"isJoi\": true,\n        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n        \"_type\": \"any\",\n        \"_settings\": null,\n        \"_valids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_invalids\": {\n          \"_set\": {},\n          \"_hasRef\": false\n        },\n        \"_tests\": [],\n        \"_refs\": [],\n        \"_flags\": {},\n        \"_description\": null,\n        \"_unit\": null,\n        \"_notes\": [],\n        \"_tags\": [],\n        \"_examples\": [],\n        \"_meta\": [],\n        \"_inner\": {},\n        \"any\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.any() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, any, args);\\n    },\n        \"alt\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n        \"alternatives\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.alternatives, args);\\n    },\n        \"array\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.array() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.array, args);\\n    },\n        \"bool\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n        \"boolean\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.boolean() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.boolean, args);\\n    },\n        \"binary\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.binary() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.binary, args);\\n    },\n        \"date\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.date() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.date, args);\\n    },\n        \"func\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.func() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.func, args);\\n    },\n        \"number\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.number() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.number, args);\\n    },\n        \"object\": function (...args) {\\n\\n        return internals.callWithDefaults.call(this, internals.object, args);\\n    },\n        \"string\": function (...args) {\\n\\n        Hoek.assert(args.length === 0, 'Joi.string() does not allow arguments.');\\n\\n        return internals.callWithDefaults.call(this, internals.string, args);\\n    },\n        \"ref\": function (...args) {\\n\\n        return Ref.create(...args);\\n    },\n        \"isRef\": function (ref) {\\n\\n        return Ref.isRef(ref);\\n    },\n        \"validate\": function (value, ...args /*, [schema], [options], callback */) {\\n\\n        const last = args[args.length - 1];\\n        const callback = typeof last === 'function' ? last : null;\\n\\n        const count = args.length - (callback ? 1 : 0);\\n        if (count === 0) {\\n            return any.validate(value, callback);\\n        }\\n\\n        const options = count === 2 ? args[1] : {};\\n        const schema = root.compile(args[0]);\\n\\n        return schema._validateWithOptions(value, options, callback);\\n    },\n        \"describe\": function (...args) {\\n\\n        const schema = args.length ? root.compile(args[0]) : any;\\n        return schema.describe();\\n    },\n        \"compile\": function (schema) {\\n\\n        try {\\n            return Cast.schema(this, schema);\\n        }\\n        catch (err) {\\n            if (err.hasOwnProperty('path')) {\\n                err.message = err.message + '(' + err.path + ')';\\n            }\\n            throw err;\\n        }\\n    },\n        \"assert\": function (value, schema, message) {\\n\\n        root.attempt(value, schema, message);\\n    },\n        \"attempt\": function (value, schema, message) {\\n\\n        const result = root.validate(value, schema);\\n        const error = result.error;\\n        if (error) {\\n            if (!message) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = error.annotate();\\n                }\\n                throw error;\\n            }\\n\\n            if (!(message instanceof Error)) {\\n                if (typeof error.annotate === 'function') {\\n                    error.message = `${message} ${error.annotate()}`;\\n                }\\n                throw error;\\n            }\\n\\n            throw message;\\n        }\\n\\n        return result.value;\\n    },\n        \"reach\": function (schema, path) {\\n\\n        Hoek.assert(schema && schema instanceof Any, 'you must provide a joi schema');\\n        Hoek.assert(Array.isArray(path) || typeof path === 'string', 'path must be a string or an array of strings');\\n\\n        const reach = (sourceSchema, schemaPath) => {\\n\\n            if (!schemaPath.length) {\\n                return sourceSchema;\\n            }\\n\\n            const children = sourceSchema._inner.children;\\n            if (!children) {\\n                return;\\n            }\\n\\n            const key = schemaPath.shift();\\n            for (let i = 0; i < children.length; ++i) {\\n                const child = children[i];\\n                if (child.key === key) {\\n                    return reach(child.schema, schemaPath);\\n                }\\n            }\\n        };\\n\\n        const schemaPath = typeof path === 'string' ? (path ? path.split('.') : []) : path.slice();\\n\\n        return reach(schema, schemaPath);\\n    },\n        \"lazy\": function (fn) {\\n\\n        return Lazy.set(fn);\\n    },\n        \"defaults\": function (fn) {\\n\\n        Hoek.assert(typeof fn === 'function', 'Defaults must be a function');\\n\\n        let joi = Object.create(this.any());\\n        joi = fn(joi);\\n\\n        Hoek.assert(joi && joi instanceof this.constructor, 'defaults() must return a schema');\\n\\n        Object.assign(joi, this, joi.clone()); // Re-add the types from `this` but also keep the settings from joi's potential new defaults\\n\\n        joi._defaults = (schema) => {\\n\\n            if (this._defaults) {\\n                schema = this._defaults(schema);\\n                Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            }\\n\\n            schema = fn(schema);\\n            Hoek.assert(schema instanceof this.constructor, 'defaults() must return a schema');\\n            return schema;\\n        };\\n\\n        return joi;\\n    },\n        \"extend\": function (...args) {\\n\\n        const extensions = Hoek.flatten(args);\\n        Hoek.assert(extensions.length > 0, 'You need to provide at least one extension');\\n\\n        this.assert(extensions, root.extensionsSchema);\\n\\n        const joi = Object.create(this.any());\\n        Object.assign(joi, this);\\n\\n        for (let i = 0; i < extensions.length; ++i) {\\n            let extension = extensions[i];\\n\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, root.extensionSchema);\\n\\n            const base = (extension.base || this.any()).clone(); // Cloning because we're going to override language afterwards\\n            const ctor = base.constructor;\\n            const type = class extends ctor { // eslint-disable-line no-loop-func\\n\\n                constructor() {\\n\\n                    super();\\n                    if (extension.base) {\\n                        Object.assign(this, base);\\n                    }\\n\\n                    this._type = extension.name;\\n\\n                    if (extension.language) {\\n                        this._settings = Settings.concat(this._settings, {\\n                            language: {\\n                                [extension.name]: extension.language\\n                            }\\n                        });\\n                    }\\n                }\\n\\n            };\\n\\n            if (extension.coerce) {\\n                type.prototype._coerce = function (value, state, options) {\\n\\n                    if (ctor.prototype._coerce) {\\n                        const baseRet = ctor.prototype._coerce.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.coerce.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n            if (extension.pre) {\\n                type.prototype._base = function (value, state, options) {\\n\\n                    if (ctor.prototype._base) {\\n                        const baseRet = ctor.prototype._base.call(this, value, state, options);\\n\\n                        if (baseRet.errors) {\\n                            return baseRet;\\n                        }\\n\\n                        value = baseRet.value;\\n                    }\\n\\n                    const ret = extension.pre.call(this, value, state, options);\\n                    if (ret instanceof Errors.Err) {\\n                        return { value, errors: ret };\\n                    }\\n\\n                    return { value: ret };\\n                };\\n            }\\n\\n            if (extension.rules) {\\n                for (let j = 0; j < extension.rules.length; ++j) {\\n                    const rule = extension.rules[j];\\n                    const ruleArgs = rule.params ?\\n                        (rule.params instanceof Any ? rule.params._inner.children.map((k) => k.key) : Object.keys(rule.params)) :\\n                        [];\\n                    const validateArgs = rule.params ? Cast.schema(this, rule.params) : null;\\n\\n                    type.prototype[rule.name] = function (...rArgs) { // eslint-disable-line no-loop-func\\n\\n                        if (rArgs.length > ruleArgs.length) {\\n                            throw new Error('Unexpected number of arguments');\\n                        }\\n\\n                        let hasRef = false;\\n                        let arg = {};\\n\\n                        for (let k = 0; k < ruleArgs.length; ++k) {\\n                            arg[ruleArgs[k]] = rArgs[k];\\n                            if (!hasRef && Ref.isRef(rArgs[k])) {\\n                                hasRef = true;\\n                            }\\n                        }\\n\\n                        if (validateArgs) {\\n                            arg = joi.attempt(arg, validateArgs);\\n                        }\\n\\n                        let schema;\\n                        if (rule.validate) {\\n                            const validate = function (value, state, options) {\\n\\n                                return rule.validate.call(this, arg, value, state, options);\\n                            };\\n\\n                            schema = this._test(rule.name, arg, validate, {\\n                                description: rule.description,\\n                                hasRef\\n                            });\\n                        }\\n                        else {\\n                            schema = this.clone();\\n                        }\\n\\n                        if (rule.setup) {\\n                            const newSchema = rule.setup.call(schema, arg);\\n                            if (newSchema !== undefined) {\\n                                Hoek.assert(newSchema instanceof Any, `Setup of extension Joi.${this._type}().${rule.name}() must return undefined or a Joi object`);\\n                                schema = newSchema;\\n                            }\\n                        }\\n\\n                        return schema;\\n                    };\\n                }\\n            }\\n\\n            if (extension.describe) {\\n                type.prototype.describe = function () {\\n\\n                    const description = ctor.prototype.describe.call(this);\\n                    return extension.describe.call(this, description);\\n                };\\n            }\\n\\n            const instance = new type();\\n            joi[extension.name] = function (...extArgs) {\\n\\n                return internals.callWithDefaults.call(this, instance, extArgs);\\n            };\\n        }\\n\\n        return joi;\\n    },\n        \"extensionSchema\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n          \"_type\": \"object\",\n          \"_settings\": {\n            \"convert\": false\n          },\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {},\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {\n            \"children\": [\n              {\n                \"key\": \"base\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                      \"name\": \"type\",\n                      \"arg\": {\n                        \"name\": \"Joi object\",\n                        \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                      }\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"name\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"string\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": 0\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"presence\": \"required\"\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {}\n                }\n              },\n              {\n                \"key\": \"coerce\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 3\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"pre\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 3\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"language\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {},\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"describe\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"object\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [\n                    {\n                      \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                      \"name\": \"arity\",\n                      \"arg\": 1\n                    }\n                  ],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"func\": true\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"children\": null,\n                    \"renames\": [],\n                    \"dependencies\": [],\n                    \"patterns\": []\n                  }\n                }\n              },\n              {\n                \"key\": \"rules\",\n                \"schema\": {\n                  \"isJoi\": true,\n                  \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                  \"_type\": \"array\",\n                  \"_settings\": null,\n                  \"_valids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_invalids\": {\n                    \"_set\": {},\n                    \"_hasRef\": false\n                  },\n                  \"_tests\": [],\n                  \"_refs\": [],\n                  \"_flags\": {\n                    \"sparse\": false\n                  },\n                  \"_description\": null,\n                  \"_unit\": null,\n                  \"_notes\": [],\n                  \"_tags\": [],\n                  \"_examples\": [],\n                  \"_meta\": [],\n                  \"_inner\": {\n                    \"items\": [\n                      {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": [\n                            {\n                              \"key\": \"name\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"string\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": 0\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"presence\": \"required\"\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {}\n                              }\n                            },\n                            {\n                              \"key\": \"setup\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 1\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"validate\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 4\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"params\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": [\n                                            {\n                                              \"regex\": {},\n                                              \"rule\": {\n                                                \"isJoi\": true,\n                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                                \"_type\": \"object\",\n                                                \"_settings\": null,\n                                                \"_valids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_invalids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_tests\": [\n                                                  {\n                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                    \"name\": \"type\",\n                                                    \"arg\": {\n                                                      \"name\": \"Joi object\",\n                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                    }\n                                                  }\n                                                ],\n                                                \"_refs\": [],\n                                                \"_flags\": {},\n                                                \"_description\": null,\n                                                \"_unit\": null,\n                                                \"_notes\": [],\n                                                \"_tags\": [],\n                                                \"_examples\": [],\n                                                \"_meta\": [],\n                                                \"_inner\": {\n                                                  \"children\": null,\n                                                  \"renames\": [],\n                                                  \"dependencies\": [],\n                                                  \"patterns\": []\n                                                }\n                                              }\n                                            }\n                                          ]\n                                        }\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                            \"name\": \"type\",\n                                            \"arg\": {\n                                              \"name\": \"Joi object\",\n                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                            }\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"description\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_type\": \"string\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": 0\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {},\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                            \"name\": \"arity\",\n                                            \"arg\": 1\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {\n                                          \"func\": true\n                                        },\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            }\n                          ],\n                          \"renames\": [],\n                          \"dependencies\": [\n                            {\n                              \"type\": \"or\",\n                              \"key\": null,\n                              \"peers\": [\n                                \"setup\",\n                                \"validate\"\n                              ]\n                            }\n                          ],\n                          \"patterns\": []\n                        }\n                      }\n                    ],\n                    \"ordereds\": [],\n                    \"inclusions\": [\n                      {\n                        \"isJoi\": true,\n                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                        \"_type\": \"object\",\n                        \"_settings\": null,\n                        \"_valids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_invalids\": {\n                          \"_set\": {},\n                          \"_hasRef\": false\n                        },\n                        \"_tests\": [],\n                        \"_refs\": [],\n                        \"_flags\": {},\n                        \"_description\": null,\n                        \"_unit\": null,\n                        \"_notes\": [],\n                        \"_tags\": [],\n                        \"_examples\": [],\n                        \"_meta\": [],\n                        \"_inner\": {\n                          \"children\": [\n                            {\n                              \"key\": \"name\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"string\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": 0\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"presence\": \"required\"\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {}\n                              }\n                            },\n                            {\n                              \"key\": \"setup\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 1\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"validate\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"object\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [\n                                  {\n                                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                    \"name\": \"arity\",\n                                    \"arg\": 4\n                                  }\n                                ],\n                                \"_refs\": [],\n                                \"_flags\": {\n                                  \"func\": true\n                                },\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"children\": null,\n                                  \"renames\": [],\n                                  \"dependencies\": [],\n                                  \"patterns\": []\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"params\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": [\n                                            {\n                                              \"regex\": {},\n                                              \"rule\": {\n                                                \"isJoi\": true,\n                                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                                \"_type\": \"object\",\n                                                \"_settings\": null,\n                                                \"_valids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_invalids\": {\n                                                  \"_set\": {},\n                                                  \"_hasRef\": false\n                                                },\n                                                \"_tests\": [\n                                                  {\n                                                    \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                                    \"name\": \"type\",\n                                                    \"arg\": {\n                                                      \"name\": \"Joi object\",\n                                                      \"ctor\": \"[class {\\n\\n    constructor() {\\n\\n        Cast = Cast || require('../../cast');\\n\\n        this.isJoi = true;\\n        this._type = 'any';\\n        this._settings = null;\\n        this._valids = new internals.Set();\\n        this._invalids = new internals.Set();\\n        this._tests = [];\\n        this._refs = [];\\n        this._flags = {\\n            /*\\n             presence: 'optional',                   // optional, required, forbidden, ignore\\n             allowOnly: false,\\n             allowUnknown: undefined,\\n             default: undefined,\\n             forbidden: false,\\n             encoding: undefined,\\n             insensitive: false,\\n             trim: false,\\n             normalize: undefined,                   // NFC, NFD, NFKC, NFKD\\n             case: undefined,                        // upper, lower\\n             empty: undefined,\\n             func: false,\\n             raw: false\\n             */\\n        };\\n\\n        this._description = null;\\n        this._unit = null;\\n        this._notes = [];\\n        this._tags = [];\\n        this._examples = [];\\n        this._meta = [];\\n\\n        this._inner = {};                           // Hash of arrays of immutable objects\\n    }\\n\\n    _init() {\\n\\n        return this;\\n    }\\n\\n    get schemaType() {\\n\\n        return this._type;\\n    }\\n\\n    createError(type, context, state, options, flags = this._flags) {\\n\\n        return Errors.create(type, context, state, options, flags);\\n    }\\n\\n    createOverrideError(type, context, state, options, message, template) {\\n\\n        return Errors.create(type, context, state, options, this._flags, message, template);\\n    }\\n\\n    checkOptions(options) {\\n\\n        const Schemas = require('../../schemas');\\n        const result = Schemas.options.validate(options);\\n        if (result.error) {\\n            throw new Error(result.error.details[0].message);\\n        }\\n    }\\n\\n    clone() {\\n\\n        const obj = Object.create(Object.getPrototypeOf(this));\\n\\n        obj.isJoi = true;\\n        obj._currentJoi = this._currentJoi;\\n        obj._type = this._type;\\n        obj._settings = this._settings;\\n        obj._baseType = this._baseType;\\n        obj._valids = this._valids.slice();\\n        obj._invalids = this._invalids.slice();\\n        obj._tests = this._tests.slice();\\n        obj._refs = this._refs.slice();\\n        obj._flags = Hoek.clone(this._flags);\\n\\n        obj._description = this._description;\\n        obj._unit = this._unit;\\n        obj._notes = this._notes.slice();\\n        obj._tags = this._tags.slice();\\n        obj._examples = this._examples.slice();\\n        obj._meta = this._meta.slice();\\n\\n        obj._inner = {};\\n        const inners = Object.keys(this._inner);\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            obj._inner[key] = this._inner[key] ? this._inner[key].slice() : null;\\n        }\\n\\n        return obj;\\n    }\\n\\n    concat(schema) {\\n\\n        Hoek.assert(schema instanceof internals.Any, 'Invalid schema object');\\n        Hoek.assert(this._type === 'any' || schema._type === 'any' || schema._type === this._type, 'Cannot merge type', this._type, 'with another type:', schema._type);\\n\\n        let obj = this.clone();\\n\\n        if (this._type === 'any' && schema._type !== 'any') {\\n\\n            // Reset values as if we were \\\"this\\\"\\n            const tmpObj = schema.clone();\\n            const keysToRestore = ['_settings', '_valids', '_invalids', '_tests', '_refs', '_flags', '_description', '_unit',\\n                '_notes', '_tags', '_examples', '_meta', '_inner'];\\n\\n            for (let i = 0; i < keysToRestore.length; ++i) {\\n                tmpObj[keysToRestore[i]] = obj[keysToRestore[i]];\\n            }\\n\\n            obj = tmpObj;\\n        }\\n\\n        obj._settings = obj._settings ? Settings.concat(obj._settings, schema._settings) : schema._settings;\\n        obj._valids.merge(schema._valids, schema._invalids);\\n        obj._invalids.merge(schema._invalids, schema._valids);\\n        obj._tests = obj._tests.concat(schema._tests);\\n        obj._refs = obj._refs.concat(schema._refs);\\n        Hoek.merge(obj._flags, schema._flags);\\n\\n        obj._description = schema._description || obj._description;\\n        obj._unit = schema._unit || obj._unit;\\n        obj._notes = obj._notes.concat(schema._notes);\\n        obj._tags = obj._tags.concat(schema._tags);\\n        obj._examples = obj._examples.concat(schema._examples);\\n        obj._meta = obj._meta.concat(schema._meta);\\n\\n        const inners = Object.keys(schema._inner);\\n        const isObject = obj._type === 'object';\\n        for (let i = 0; i < inners.length; ++i) {\\n            const key = inners[i];\\n            const source = schema._inner[key];\\n            if (source) {\\n                const target = obj._inner[key];\\n                if (target) {\\n                    if (isObject && key === 'children') {\\n                        const keys = {};\\n\\n                        for (let j = 0; j < target.length; ++j) {\\n                            keys[target[j].key] = j;\\n                        }\\n\\n                        for (let j = 0; j < source.length; ++j) {\\n                            const sourceKey = source[j].key;\\n                            if (keys[sourceKey] >= 0) {\\n                                target[keys[sourceKey]] = {\\n                                    key: sourceKey,\\n                                    schema: target[keys[sourceKey]].schema.concat(source[j].schema)\\n                                };\\n                            }\\n                            else {\\n                                target.push(source[j]);\\n                            }\\n                        }\\n                    }\\n                    else {\\n                        obj._inner[key] = obj._inner[key].concat(source);\\n                    }\\n                }\\n                else {\\n                    obj._inner[key] = source.slice();\\n                }\\n            }\\n        }\\n\\n        return obj;\\n    }\\n\\n    _test(name, arg, func, options) {\\n\\n        const obj = this.clone();\\n        obj._tests.push({ func, name, arg, options });\\n        return obj;\\n    }\\n\\n    options(options) {\\n\\n        Hoek.assert(!options.context, 'Cannot override context');\\n        this.checkOptions(options);\\n\\n        const obj = this.clone();\\n        obj._settings = Settings.concat(obj._settings, options);\\n        return obj;\\n    }\\n\\n    strict(isStrict) {\\n\\n        const obj = this.clone();\\n\\n        const convert = isStrict === undefined ? false : !isStrict;\\n        obj._settings = Settings.concat(obj._settings, { convert });\\n        return obj;\\n    }\\n\\n    raw(isRaw) {\\n\\n        const value = isRaw === undefined ? true : isRaw;\\n\\n        if (this._flags.raw === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.raw = value;\\n        return obj;\\n    }\\n\\n    error(err) {\\n\\n        Hoek.assert(err && (err instanceof Error || typeof err === 'function'), 'Must provide a valid Error object or a function');\\n\\n        const obj = this.clone();\\n        obj._flags.error = err;\\n        return obj;\\n    }\\n\\n    allow(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._invalids.remove(value);\\n            obj._valids.add(value, obj._refs);\\n        }\\n        return obj;\\n    }\\n\\n    valid(...values) {\\n\\n        const obj = this.allow(...values);\\n        obj._flags.allowOnly = true;\\n        return obj;\\n    }\\n\\n    invalid(...values) {\\n\\n        const obj = this.clone();\\n        values = Hoek.flatten(values);\\n        for (let i = 0; i < values.length; ++i) {\\n            const value = values[i];\\n\\n            Hoek.assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\\n            obj._valids.remove(value);\\n            obj._invalids.add(value, obj._refs);\\n        }\\n\\n        return obj;\\n    }\\n\\n    required() {\\n\\n        if (this._flags.presence === 'required') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'required';\\n        return obj;\\n    }\\n\\n    optional() {\\n\\n        if (this._flags.presence === 'optional') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'optional';\\n        return obj;\\n    }\\n\\n\\n    forbidden() {\\n\\n        if (this._flags.presence === 'forbidden') {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.presence = 'forbidden';\\n        return obj;\\n    }\\n\\n\\n    strip() {\\n\\n        if (this._flags.strip) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.strip = true;\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n\\n        if (children.length !== 1 || children[0] !== '') {\\n            root = root ? (root + '.') : '';\\n\\n            const extraChildren = (children[0] === '' ? children.slice(1) : children).map((child) => {\\n\\n                return root + child;\\n            });\\n\\n            throw new Error('unknown key(s) ' + extraChildren.join(', '));\\n        }\\n\\n        return this[fn].apply(this, args);\\n    }\\n\\n    default(value, description) {\\n\\n        if (typeof value === 'function' &&\\n            !Ref.isRef(value)) {\\n\\n            if (!value.description &&\\n                description) {\\n\\n                value.description = description;\\n            }\\n\\n            if (!this._flags.func) {\\n                Hoek.assert(typeof value.description === 'string' && value.description.length > 0, 'description must be provided when default value is a function');\\n            }\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.default = value;\\n        Ref.push(obj._refs, value);\\n        return obj;\\n    }\\n\\n    empty(schema) {\\n\\n        const obj = this.clone();\\n        if (schema === undefined) {\\n            delete obj._flags.empty;\\n        }\\n        else {\\n            obj._flags.empty = Cast.schema(this._currentJoi, schema);\\n        }\\n        return obj;\\n    }\\n\\n    when(condition, options) {\\n\\n        Hoek.assert(options && typeof options === 'object', 'Invalid options');\\n        Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \\\"then\\\" or \\\"otherwise\\\"');\\n\\n        const then = options.hasOwnProperty('then') ? this.concat(Cast.schema(this._currentJoi, options.then)) : undefined;\\n        const otherwise = options.hasOwnProperty('otherwise') ? this.concat(Cast.schema(this._currentJoi, options.otherwise)) : undefined;\\n\\n        Alternatives = Alternatives || require('../alternatives');\\n\\n        const alternativeOptions = { then, otherwise };\\n        if (Object.prototype.hasOwnProperty.call(options, 'is')) {\\n            alternativeOptions.is = options.is;\\n        }\\n        const obj = Alternatives.when(condition, alternativeOptions);\\n        obj._flags.presence = 'ignore';\\n        obj._baseType = this;\\n\\n        return obj;\\n    }\\n\\n    description(desc) {\\n\\n        Hoek.assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._description = desc;\\n        return obj;\\n    }\\n\\n    notes(notes) {\\n\\n        Hoek.assert(notes && (typeof notes === 'string' || Array.isArray(notes)), 'Notes must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._notes = obj._notes.concat(notes);\\n        return obj;\\n    }\\n\\n    tags(tags) {\\n\\n        Hoek.assert(tags && (typeof tags === 'string' || Array.isArray(tags)), 'Tags must be a non-empty string or array');\\n\\n        const obj = this.clone();\\n        obj._tags = obj._tags.concat(tags);\\n        return obj;\\n    }\\n\\n    meta(meta) {\\n\\n        Hoek.assert(meta !== undefined, 'Meta cannot be undefined');\\n\\n        const obj = this.clone();\\n        obj._meta = obj._meta.concat(meta);\\n        return obj;\\n    }\\n\\n    example(...args) {\\n\\n        Hoek.assert(args.length === 1, 'Missing example');\\n        const value = args[0];\\n\\n        const obj = this.clone();\\n        obj._examples.push(value);\\n        return obj;\\n    }\\n\\n    unit(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._unit = name;\\n        return obj;\\n    }\\n\\n    _prepareEmptyValue(value) {\\n\\n        if (typeof value === 'string' && this._flags.trim) {\\n            return value.trim();\\n        }\\n\\n        return value;\\n    }\\n\\n    _validate(value, state, options, reference) {\\n\\n        const originalValue = value;\\n\\n        // Setup state and settings\\n\\n        state = state || { key: '', path: [], parent: null, reference };\\n\\n        if (this._settings) {\\n            options = Settings.concat(options, this._settings);\\n        }\\n\\n        let errors = [];\\n        const finish = () => {\\n\\n            let finalValue;\\n\\n            if (value !== undefined) {\\n                finalValue = this._flags.raw ? originalValue : value;\\n            }\\n            else if (options.noDefaults) {\\n                finalValue = value;\\n            }\\n            else if (Ref.isRef(this._flags.default)) {\\n                finalValue = this._flags.default(state.parent, options);\\n            }\\n            else if (typeof this._flags.default === 'function' &&\\n                !(this._flags.func && !this._flags.default.description)) {\\n\\n                let args;\\n\\n                if (state.parent !== null &&\\n                    this._flags.default.length > 0) {\\n\\n                    args = [Hoek.clone(state.parent), options];\\n                }\\n\\n                const defaultValue = internals._try(this._flags.default, args);\\n                finalValue = defaultValue.value;\\n                if (defaultValue.error) {\\n                    errors.push(this.createError('any.default', { error: defaultValue.error }, state, options));\\n                }\\n            }\\n            else {\\n                finalValue = Hoek.clone(this._flags.default);\\n            }\\n\\n            if (errors.length && typeof this._flags.error === 'function') {\\n                const change = this._flags.error.call(this, errors);\\n\\n                if (typeof change === 'string') {\\n                    errors = [this.createOverrideError('override', { reason: errors }, state, options, change)];\\n                }\\n                else {\\n                    errors = [].concat(change)\\n                        .map((err) => {\\n\\n                            return err instanceof Error ?\\n                                err :\\n                                this.createOverrideError(err.type || 'override', err.context, state, options, err.message, err.template);\\n                        });\\n                }\\n            }\\n\\n            return {\\n                value: this._flags.strip ? undefined : finalValue,\\n                finalValue,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (this._coerce) {\\n            const coerced = this._coerce.call(this, value, state, options);\\n            if (coerced.errors) {\\n                value = coerced.value;\\n                errors = errors.concat(coerced.errors);\\n                return finish();                            // Coerced error always aborts early\\n            }\\n\\n            value = coerced.value;\\n        }\\n\\n        if (this._flags.empty && !this._flags.empty._validate(this._prepareEmptyValue(value), null, internals.defaults).errors) {\\n            value = undefined;\\n        }\\n\\n        // Check presence requirements\\n\\n        const presence = this._flags.presence || options.presence;\\n        if (presence === 'optional') {\\n            if (value === undefined) {\\n                const isDeepDefault = this._flags.hasOwnProperty('default') && this._flags.default === undefined;\\n                if (isDeepDefault && this._type === 'object') {\\n                    value = {};\\n                }\\n                else {\\n                    return finish();\\n                }\\n            }\\n        }\\n        else if (presence === 'required' &&\\n            value === undefined) {\\n\\n            errors.push(this.createError('any.required', null, state, options));\\n            return finish();\\n        }\\n        else if (presence === 'forbidden') {\\n            if (value === undefined) {\\n                return finish();\\n            }\\n\\n            errors.push(this.createError('any.unknown', null, state, options));\\n            return finish();\\n        }\\n\\n        // Check allowed and denied values using the original value\\n\\n        if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n            return finish();\\n        }\\n\\n        if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n            errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly ||\\n                value === undefined) {          // No reason to keep validating missing value\\n\\n                return finish();\\n            }\\n        }\\n\\n        // Convert value and validate type\\n\\n        if (this._base) {\\n            const base = this._base.call(this, value, state, options);\\n            if (base.errors) {\\n                value = base.value;\\n                errors = errors.concat(base.errors);\\n                return finish();                            // Base error always aborts early\\n            }\\n\\n            if (base.value !== value) {\\n                value = base.value;\\n\\n                // Check allowed and denied values using the converted value\\n\\n                if (this._valids.has(value, state, options, this._flags.insensitive)) {\\n                    return finish();\\n                }\\n\\n                if (this._invalids.has(value, state, options, this._flags.insensitive)) {\\n                    errors.push(this.createError(value === '' ? 'any.empty' : 'any.invalid', { value, invalids: this._invalids.values({ stripUndefined: true }) }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Required values did not match\\n\\n        if (this._flags.allowOnly) {\\n            errors.push(this.createError('any.allowOnly', { value, valids: this._valids.values({ stripUndefined: true }) }, state, options));\\n            if (options.abortEarly) {\\n                return finish();\\n            }\\n        }\\n\\n        // Validate tests\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const test = this._tests[i];\\n            const ret = test.func.call(this, value, state, options);\\n            if (ret instanceof Errors.Err) {\\n                errors.push(ret);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n            else {\\n                value = ret;\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    _validateWithOptions(value, options, callback) {\\n\\n        if (options) {\\n            this.checkOptions(options);\\n        }\\n\\n        const settings = Settings.concat(internals.defaults, options);\\n        const result = this._validate(value, null, settings);\\n        const errors = Errors.process(result.errors, value);\\n\\n        if (callback) {\\n            return callback(errors, result.value);\\n        }\\n\\n        return {\\n            error: errors,\\n            value: result.value,\\n            then(resolve, reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value).then(resolve);\\n            },\\n            catch(reject) {\\n\\n                if (errors) {\\n                    return Promise.reject(errors).catch(reject);\\n                }\\n\\n                return Promise.resolve(result.value);\\n            }\\n        };\\n    }\\n\\n    validate(value, options, callback) {\\n\\n        if (typeof options === 'function') {\\n            return this._validateWithOptions(value, null, options);\\n        }\\n\\n        return this._validateWithOptions(value, options, callback);\\n    }\\n\\n    describe() {\\n\\n        const description = {\\n            type: this._type\\n        };\\n\\n        const flags = Object.keys(this._flags);\\n        if (flags.length) {\\n            if (['empty', 'default', 'lazy', 'label'].some((flag) => this._flags.hasOwnProperty(flag))) {\\n                description.flags = {};\\n                for (let i = 0; i < flags.length; ++i) {\\n                    const flag = flags[i];\\n                    if (flag === 'empty') {\\n                        description.flags[flag] = this._flags[flag].describe();\\n                    }\\n                    else if (flag === 'default') {\\n                        if (Ref.isRef(this._flags[flag])) {\\n                            description.flags[flag] = this._flags[flag].toString();\\n                        }\\n                        else if (typeof this._flags[flag] === 'function') {\\n                            description.flags[flag] = {\\n                                description: this._flags[flag].description,\\n                                function   : this._flags[flag]\\n                            };\\n                        }\\n                        else {\\n                            description.flags[flag] = this._flags[flag];\\n                        }\\n                    }\\n                    else if (flag === 'lazy' || flag === 'label') {\\n                        // We don't want it in the description\\n                    }\\n                    else {\\n                        description.flags[flag] = this._flags[flag];\\n                    }\\n                }\\n            }\\n            else {\\n                description.flags = this._flags;\\n            }\\n        }\\n\\n        if (this._settings) {\\n            description.options = Hoek.clone(this._settings);\\n        }\\n\\n        if (this._baseType) {\\n            description.base = this._baseType.describe();\\n        }\\n\\n        if (this._description) {\\n            description.description = this._description;\\n        }\\n\\n        if (this._notes.length) {\\n            description.notes = this._notes;\\n        }\\n\\n        if (this._tags.length) {\\n            description.tags = this._tags;\\n        }\\n\\n        if (this._meta.length) {\\n            description.meta = this._meta;\\n        }\\n\\n        if (this._examples.length) {\\n            description.examples = this._examples;\\n        }\\n\\n        if (this._unit) {\\n            description.unit = this._unit;\\n        }\\n\\n        const valids = this._valids.values();\\n        if (valids.length) {\\n            description.valids = valids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        const invalids = this._invalids.values();\\n        if (invalids.length) {\\n            description.invalids = invalids.map((v) => {\\n\\n                return Ref.isRef(v) ? v.toString() : v;\\n            });\\n        }\\n\\n        description.rules = [];\\n\\n        for (let i = 0; i < this._tests.length; ++i) {\\n            const validator = this._tests[i];\\n            const item = { name: validator.name };\\n\\n            if (validator.arg !== void 0) {\\n                item.arg = Ref.isRef(validator.arg) ? validator.arg.toString() : validator.arg;\\n            }\\n\\n            const options = validator.options;\\n            if (options) {\\n                if (options.hasRef) {\\n                    item.arg = {};\\n                    const keys = Object.keys(validator.arg);\\n                    for (let j = 0; j < keys.length; ++j) {\\n                        const key = keys[j];\\n                        const value = validator.arg[key];\\n                        item.arg[key] = Ref.isRef(value) ? value.toString() : value;\\n                    }\\n                }\\n\\n                if (typeof options.description === 'string') {\\n                    item.description = options.description;\\n                }\\n                else if (typeof options.description === 'function') {\\n                    item.description = options.description(item.arg);\\n                }\\n            }\\n\\n            description.rules.push(item);\\n        }\\n\\n        if (!description.rules.length) {\\n            delete description.rules;\\n        }\\n\\n        const label = this._getLabel();\\n        if (label) {\\n            description.label = label;\\n        }\\n\\n        return description;\\n    }\\n\\n    label(name) {\\n\\n        Hoek.assert(name && typeof name === 'string', 'Label name must be a non-empty string');\\n\\n        const obj = this.clone();\\n        obj._flags.label = name;\\n        return obj;\\n    }\\n\\n    _getLabel(def) {\\n\\n        return this._flags.label || def;\\n    }\\n\\n}]\"\n                                                    }\n                                                  }\n                                                ],\n                                                \"_refs\": [],\n                                                \"_flags\": {},\n                                                \"_description\": null,\n                                                \"_unit\": null,\n                                                \"_notes\": [],\n                                                \"_tags\": [],\n                                                \"_examples\": [],\n                                                \"_meta\": [],\n                                                \"_inner\": {\n                                                  \"children\": null,\n                                                  \"renames\": [],\n                                                  \"dependencies\": [],\n                                                  \"patterns\": []\n                                                }\n                                              }\n                                            }\n                                          ]\n                                        }\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        },\n                                            \"name\": \"type\",\n                                            \"arg\": {\n                                              \"name\": \"Joi object\",\n                                              \"ctor\": \"[class extends Any {\\n\\n    constructor() {\\n\\n        super();\\n        this._type = 'object';\\n        this._inner.children = null;\\n        this._inner.renames = [];\\n        this._inner.dependencies = [];\\n        this._inner.patterns = [];\\n    }\\n\\n    _init(...args) {\\n\\n        return args.length ? this.keys(...args) : this;\\n    }\\n\\n    _base(value, state, options) {\\n\\n        let target = value;\\n        const errors = [];\\n        const finish = () => {\\n\\n            return {\\n                value: target,\\n                errors: errors.length ? errors : null\\n            };\\n        };\\n\\n        if (typeof value === 'string' &&\\n            options.convert) {\\n\\n            value = internals.safeParse(value);\\n        }\\n\\n        const type = this._flags.func ? 'function' : 'object';\\n        if (!value ||\\n            typeof value !== type ||\\n            Array.isArray(value)) {\\n\\n            errors.push(this.createError(type + '.base', null, state, options));\\n            return finish();\\n        }\\n\\n        // Skip if there are no other rules to test\\n\\n        if (!this._inner.renames.length &&\\n            !this._inner.dependencies.length &&\\n            !this._inner.children &&                    // null allows any keys\\n            !this._inner.patterns.length) {\\n\\n            target = value;\\n            return finish();\\n        }\\n\\n        // Ensure target is a local copy (parsed) or shallow copy\\n\\n        if (target === value) {\\n            if (type === 'object') {\\n                target = Object.create(Object.getPrototypeOf(value));\\n            }\\n            else {\\n                target = function (...args) {\\n\\n                    return value.apply(this, args);\\n                };\\n\\n                target.prototype = Hoek.clone(value.prototype);\\n            }\\n\\n            const valueKeys = Object.keys(value);\\n            for (let i = 0; i < valueKeys.length; ++i) {\\n                target[valueKeys[i]] = value[valueKeys[i]];\\n            }\\n        }\\n        else {\\n            target = value;\\n        }\\n\\n        // Rename keys\\n\\n        const renamed = {};\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            const rename = this._inner.renames[i];\\n\\n            if (rename.isRegExp) {\\n                const targetKeys = Object.keys(target);\\n                const matchedTargetKeys = [];\\n\\n                for (let j = 0; j < targetKeys.length; ++j) {\\n                    if (rename.from.test(targetKeys[j])) {\\n                        matchedTargetKeys.push(targetKeys[j]);\\n                    }\\n                }\\n\\n                const allUndefined = matchedTargetKeys.every((key) => target[key] === undefined);\\n                if (rename.options.ignoreUndefined && allUndefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.multiple', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.regex.override', { from: matchedTargetKeys, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (allUndefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[matchedTargetKeys[matchedTargetKeys.length - 1]];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    for (let j = 0; j < matchedTargetKeys.length; ++j) {\\n                        delete target[matchedTargetKeys[j]];\\n                    }\\n                }\\n            }\\n            else {\\n                if (rename.options.ignoreUndefined && target[rename.from] === undefined) {\\n                    continue;\\n                }\\n\\n                if (!rename.options.multiple &&\\n                    renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.multiple', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (Object.prototype.hasOwnProperty.call(target, rename.to) &&\\n                    !rename.options.override &&\\n                    !renamed[rename.to]) {\\n\\n                    errors.push(this.createError('object.rename.override', { from: rename.from, to: rename.to }, state, options));\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n\\n                if (target[rename.from] === undefined) {\\n                    delete target[rename.to];\\n                }\\n                else {\\n                    target[rename.to] = target[rename.from];\\n                }\\n\\n                renamed[rename.to] = true;\\n\\n                if (!rename.options.alias) {\\n                    delete target[rename.from];\\n                }\\n            }\\n        }\\n\\n        // Validate schema\\n\\n        if (!this._inner.children &&            // null allows any keys\\n            !this._inner.patterns.length &&\\n            !this._inner.dependencies.length) {\\n\\n            return finish();\\n        }\\n\\n        const unprocessed = new Set(Object.keys(target));\\n\\n        if (this._inner.children) {\\n            const stripProps = [];\\n\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                const key = child.key;\\n                const item = target[key];\\n\\n                unprocessed.delete(key);\\n\\n                const localState = { key, path: state.path.concat(key), parent: target, reference: state.reference };\\n                const result = child.schema._validate(item, localState, options);\\n                if (result.errors) {\\n                    errors.push(this.createError('object.child', { key, child: child.schema._getLabel(key), reason: result.errors }, localState, options));\\n\\n                    if (options.abortEarly) {\\n                        return finish();\\n                    }\\n                }\\n                else {\\n                    if (child.schema._flags.strip || (result.value === undefined && result.value !== item)) {\\n                        stripProps.push(key);\\n                        target[key] = result.finalValue;\\n                    }\\n                    else if (result.value !== undefined) {\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n\\n            for (let i = 0; i < stripProps.length; ++i) {\\n                delete target[stripProps[i]];\\n            }\\n        }\\n\\n        // Unknown keys\\n\\n        if (unprocessed.size && this._inner.patterns.length) {\\n\\n            for (const key of unprocessed) {\\n                const localState = {\\n                    key,\\n                    path: state.path.concat(key),\\n                    parent: target,\\n                    reference: state.reference\\n                };\\n                const item = target[key];\\n\\n                for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                    const pattern = this._inner.patterns[i];\\n\\n                    if (pattern.regex ?\\n                        pattern.regex.test(key) :\\n                        !pattern.schema.validate(key).error) {\\n\\n                        unprocessed.delete(key);\\n\\n                        const result = pattern.rule._validate(item, localState, options);\\n                        if (result.errors) {\\n                            errors.push(this.createError('object.child', {\\n                                key,\\n                                child: pattern.rule._getLabel(key),\\n                                reason: result.errors\\n                            }, localState, options));\\n\\n                            if (options.abortEarly) {\\n                                return finish();\\n                            }\\n                        }\\n\\n                        target[key] = result.value;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (unprocessed.size && (this._inner.children || this._inner.patterns.length)) {\\n            if ((options.stripUnknown && this._flags.allowUnknown !== true) ||\\n                options.skipFunctions) {\\n\\n                const stripUnknown = options.stripUnknown\\n                    ? (options.stripUnknown === true ? true : !!options.stripUnknown.objects)\\n                    : false;\\n\\n\\n                for (const key of unprocessed) {\\n                    if (stripUnknown) {\\n                        delete target[key];\\n                        unprocessed.delete(key);\\n                    }\\n                    else if (typeof target[key] === 'function') {\\n                        unprocessed.delete(key);\\n                    }\\n                }\\n            }\\n\\n            if ((this._flags.allowUnknown !== undefined ? !this._flags.allowUnknown : !options.allowUnknown)) {\\n\\n                for (const unprocessedKey of unprocessed) {\\n                    errors.push(this.createError('object.allowUnknown', { child: unprocessedKey }, {\\n                        key: unprocessedKey,\\n                        path: state.path.concat(unprocessedKey)\\n                    }, options, {}));\\n                }\\n            }\\n        }\\n\\n        // Validate dependencies\\n\\n        for (let i = 0; i < this._inner.dependencies.length; ++i) {\\n            const dep = this._inner.dependencies[i];\\n            const err = internals[dep.type].call(this, dep.key !== null && target[dep.key], dep.peers, target, { key: dep.key, path: dep.key === null ? state.path : state.path.concat(dep.key) }, options);\\n            if (err instanceof Errors.Err) {\\n                errors.push(err);\\n                if (options.abortEarly) {\\n                    return finish();\\n                }\\n            }\\n        }\\n\\n        return finish();\\n    }\\n\\n    keys(schema) {\\n\\n        Hoek.assert(schema === null || schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\\n        Hoek.assert(!schema || !(schema instanceof Any), 'Object schema cannot be a joi schema');\\n\\n        const obj = this.clone();\\n\\n        if (!schema) {\\n            obj._inner.children = null;\\n            return obj;\\n        }\\n\\n        const children = Object.keys(schema);\\n\\n        if (!children.length) {\\n            obj._inner.children = [];\\n            return obj;\\n        }\\n\\n        const topo = new Topo();\\n        if (obj._inner.children) {\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n\\n                // Only add the key if we are not going to replace it later\\n                if (!children.includes(child.key)) {\\n                    topo.add(child, { after: child._refs, group: child.key });\\n                }\\n            }\\n        }\\n\\n        for (let i = 0; i < children.length; ++i) {\\n            const key = children[i];\\n            const child = schema[key];\\n            try {\\n                const cast = Cast.schema(this._currentJoi, child);\\n                topo.add({ key, schema: cast }, { after: cast._refs, group: key });\\n            }\\n            catch (castErr) {\\n                if (castErr.hasOwnProperty('path')) {\\n                    castErr.path = key + '.' + castErr.path;\\n                }\\n                else {\\n                    castErr.path = key;\\n                }\\n                throw castErr;\\n            }\\n        }\\n\\n        obj._inner.children = topo.nodes;\\n\\n        return obj;\\n    }\\n\\n    append(schema) {\\n        // Skip any changes\\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\\n            return this;\\n        }\\n\\n        return this.keys(schema);\\n    }\\n\\n    unknown(allow) {\\n\\n        const value = allow !== false;\\n\\n        if (this._flags.allowUnknown === value) {\\n            return this;\\n        }\\n\\n        const obj = this.clone();\\n        obj._flags.allowUnknown = value;\\n        return obj;\\n    }\\n\\n    length(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('length', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length === limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.length', { limit }, state, options);\\n        });\\n    }\\n\\n    min(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('min', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length >= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.min', { limit }, state, options);\\n        });\\n    }\\n\\n    max(limit) {\\n\\n        Hoek.assert(Number.isSafeInteger(limit) && limit >= 0, 'limit must be a positive integer');\\n\\n        return this._test('max', limit, function (value, state, options) {\\n\\n            if (Object.keys(value).length <= limit) {\\n                return value;\\n            }\\n\\n            return this.createError('object.max', { limit }, state, options);\\n        });\\n    }\\n\\n    pattern(pattern, schema) {\\n\\n        const isRegExp = pattern instanceof RegExp;\\n        Hoek.assert(isRegExp || pattern instanceof Any, 'pattern must be a regex or schema');\\n        Hoek.assert(schema !== undefined, 'Invalid rule');\\n\\n        if (isRegExp) {\\n            pattern = new RegExp(pattern.source, pattern.ignoreCase ? 'i' : undefined);         // Future version should break this and forbid unsupported regex flags\\n        }\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const obj = this.clone();\\n        if (isRegExp) {\\n            obj._inner.patterns.push({ regex: pattern, rule: schema });\\n        }\\n        else {\\n            obj._inner.patterns.push({ schema: pattern, rule: schema });\\n        }\\n        return obj;\\n    }\\n\\n    schema() {\\n\\n        return this._test('schema', null, function (value, state, options) {\\n\\n            if (value instanceof Any) {\\n                return value;\\n            }\\n\\n            return this.createError('object.schema', null, state, options);\\n        });\\n    }\\n\\n    with(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('with', key, peers);\\n    }\\n\\n    without(key, peers) {\\n\\n        Hoek.assert(arguments.length === 2, 'Invalid number of arguments, expected 2.');\\n\\n        return this._dependency('without', key, peers);\\n    }\\n\\n    xor(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('xor', null, peers);\\n    }\\n\\n    or(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('or', null, peers);\\n    }\\n\\n    and(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('and', null, peers);\\n    }\\n\\n    nand(...peers) {\\n\\n        peers = Hoek.flatten(peers);\\n        return this._dependency('nand', null, peers);\\n    }\\n\\n    requiredKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'required');\\n    }\\n\\n    optionalKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'optional');\\n    }\\n\\n    forbiddenKeys(...children) {\\n\\n        children = Hoek.flatten(children);\\n        return this.applyFunctionToChildren(children, 'forbidden');\\n    }\\n\\n    rename(from, to, options) {\\n\\n        Hoek.assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\\n        Hoek.assert(typeof to === 'string', 'Rename missing the to argument');\\n        Hoek.assert(to !== from, 'Cannot rename key to same name:', from);\\n\\n        for (let i = 0; i < this._inner.renames.length; ++i) {\\n            Hoek.assert(this._inner.renames[i].from !== from, 'Cannot rename the same key multiple times');\\n        }\\n\\n        const obj = this.clone();\\n\\n        obj._inner.renames.push({\\n            from,\\n            to,\\n            options: Hoek.applyToDefaults(internals.renameDefaults, options || {}),\\n            isRegExp: from instanceof RegExp\\n        });\\n\\n        return obj;\\n    }\\n\\n    applyFunctionToChildren(children, fn, args, root) {\\n\\n        children = [].concat(children);\\n        Hoek.assert(children.length > 0, 'expected at least one children');\\n\\n        const groupedChildren = internals.groupChildren(children);\\n        let obj;\\n\\n        if ('' in groupedChildren) {\\n            obj = this[fn].apply(this, args);\\n            delete groupedChildren[''];\\n        }\\n        else {\\n            obj = this.clone();\\n        }\\n\\n        if (obj._inner.children) {\\n            root = root ? (root + '.') : '';\\n\\n            for (let i = 0; i < obj._inner.children.length; ++i) {\\n                const child = obj._inner.children[i];\\n                const group = groupedChildren[child.key];\\n\\n                if (group) {\\n                    obj._inner.children[i] = {\\n                        key: child.key,\\n                        _refs: child._refs,\\n                        schema: child.schema.applyFunctionToChildren(group, fn, args, root + child.key)\\n                    };\\n\\n                    delete groupedChildren[child.key];\\n                }\\n            }\\n        }\\n\\n        const remaining = Object.keys(groupedChildren);\\n        Hoek.assert(remaining.length === 0, 'unknown key(s)', remaining.join(', '));\\n\\n        return obj;\\n    }\\n\\n    _dependency(type, key, peers) {\\n\\n        peers = [].concat(peers);\\n        for (let i = 0; i < peers.length; ++i) {\\n            Hoek.assert(typeof peers[i] === 'string', type, 'peers must be a string or array of strings');\\n        }\\n\\n        const obj = this.clone();\\n        obj._inner.dependencies.push({ type, key, peers });\\n        return obj;\\n    }\\n\\n    describe(shallow) {\\n\\n        const description = Any.prototype.describe.call(this);\\n\\n        if (description.rules) {\\n            for (let i = 0; i < description.rules.length; ++i) {\\n                const rule = description.rules[i];\\n                // Coverage off for future-proof descriptions, only object().assert() is use right now\\n                if (/* $lab:coverage:off$ */rule.arg &&\\n                    typeof rule.arg === 'object' &&\\n                    rule.arg.schema &&\\n                    rule.arg.ref /* $lab:coverage:on$ */) {\\n                    rule.arg = {\\n                        schema: rule.arg.schema.describe(),\\n                        ref: rule.arg.ref.toString()\\n                    };\\n                }\\n            }\\n        }\\n\\n        if (this._inner.children &&\\n            !shallow) {\\n\\n            description.children = {};\\n            for (let i = 0; i < this._inner.children.length; ++i) {\\n                const child = this._inner.children[i];\\n                description.children[child.key] = child.schema.describe();\\n            }\\n        }\\n\\n        if (this._inner.dependencies.length) {\\n            description.dependencies = Hoek.clone(this._inner.dependencies);\\n        }\\n\\n        if (this._inner.patterns.length) {\\n            description.patterns = [];\\n\\n            for (let i = 0; i < this._inner.patterns.length; ++i) {\\n                const pattern = this._inner.patterns[i];\\n                if (pattern.regex) {\\n                    description.patterns.push({ regex: pattern.regex.toString(), rule: pattern.rule.describe() });\\n                }\\n                else {\\n                    description.patterns.push({ schema: pattern.schema.describe(), rule: pattern.rule.describe() });\\n                }\\n            }\\n        }\\n\\n        if (this._inner.renames.length > 0) {\\n            description.renames = Hoek.clone(this._inner.renames);\\n        }\\n\\n        return description;\\n    }\\n\\n    assert(ref, schema, message) {\\n\\n        ref = Cast.ref(ref);\\n        Hoek.assert(ref.isContext || ref.depth > 1, 'Cannot use assertions for root level references - use direct key rules instead');\\n        message = message || 'pass the assertion test';\\n\\n        try {\\n            schema = Cast.schema(this._currentJoi, schema);\\n        }\\n        catch (castErr) {\\n            if (castErr.hasOwnProperty('path')) {\\n                castErr.message = castErr.message + '(' + castErr.path + ')';\\n            }\\n\\n            throw castErr;\\n        }\\n\\n        const key = ref.path[ref.path.length - 1];\\n        const path = ref.path.join('.');\\n\\n        return this._test('assert', { schema, ref }, function (value, state, options) {\\n\\n            const result = schema._validate(ref(value), null, options, value);\\n            if (!result.errors) {\\n                return value;\\n            }\\n\\n            const localState = Hoek.merge({}, state);\\n            localState.key = key;\\n            localState.path = ref.path;\\n            return this.createError('object.assert', { ref: path, message }, localState, options);\\n        });\\n    }\\n\\n    type(constructor, name = constructor.name) {\\n\\n        Hoek.assert(typeof constructor === 'function', 'type must be a constructor function');\\n        const typeData = {\\n            name,\\n            ctor: constructor\\n        };\\n\\n        return this._test('type', typeData, function (value, state, options) {\\n\\n            if (value instanceof constructor) {\\n                return value;\\n            }\\n\\n            return this.createError('object.type', { type: typeData.name }, state, options);\\n        });\\n    }\\n}]\"\n                                            }\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            },\n                            {\n                              \"key\": \"description\",\n                              \"schema\": {\n                                \"isJoi\": true,\n                                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                \"_type\": \"alternatives\",\n                                \"_settings\": null,\n                                \"_valids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_invalids\": {\n                                  \"_set\": {},\n                                  \"_hasRef\": false\n                                },\n                                \"_tests\": [],\n                                \"_refs\": [],\n                                \"_flags\": {},\n                                \"_description\": null,\n                                \"_unit\": null,\n                                \"_notes\": [],\n                                \"_tags\": [],\n                                \"_examples\": [],\n                                \"_meta\": [],\n                                \"_inner\": {\n                                  \"matches\": [\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_type\": \"string\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": 0\n                                        },\n                                        \"_tests\": [],\n                                        \"_refs\": [],\n                                        \"_flags\": {},\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {},\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\"\n                                      }\n                                    },\n                                    {\n                                      \"schema\": {\n                                        \"isJoi\": true,\n                                        \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                                        \"_type\": \"object\",\n                                        \"_settings\": null,\n                                        \"_valids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_invalids\": {\n                                          \"_set\": {},\n                                          \"_hasRef\": false\n                                        },\n                                        \"_tests\": [\n                                          {\n                                            \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                                            \"name\": \"arity\",\n                                            \"arg\": 1\n                                          }\n                                        ],\n                                        \"_refs\": [],\n                                        \"_flags\": {\n                                          \"func\": true\n                                        },\n                                        \"_description\": null,\n                                        \"_unit\": null,\n                                        \"_notes\": [],\n                                        \"_tags\": [],\n                                        \"_examples\": [],\n                                        \"_meta\": [],\n                                        \"_inner\": {\n                                          \"children\": null,\n                                          \"renames\": [],\n                                          \"dependencies\": [],\n                                          \"patterns\": []\n                                        }\n                                      }\n                                    }\n                                  ]\n                                }\n                              }\n                            }\n                          ],\n                          \"renames\": [],\n                          \"dependencies\": [\n                            {\n                              \"type\": \"or\",\n                              \"key\": null,\n                              \"peers\": [\n                                \"setup\",\n                                \"validate\"\n                              ]\n                            }\n                          ],\n                          \"patterns\": []\n                        }\n                      }\n                    ],\n                    \"exclusions\": [],\n                    \"requireds\": []\n                  }\n                }\n              }\n            ],\n            \"renames\": [],\n            \"dependencies\": [],\n            \"patterns\": []\n          }\n        },\n        \"extensionsSchema\": {\n          \"isJoi\": true,\n          \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n          \"_type\": \"array\",\n          \"_settings\": {\n            \"convert\": false\n          },\n          \"_valids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_invalids\": {\n            \"_set\": {},\n            \"_hasRef\": false\n          },\n          \"_tests\": [],\n          \"_refs\": [],\n          \"_flags\": {\n            \"sparse\": false\n          },\n          \"_description\": null,\n          \"_unit\": null,\n          \"_notes\": [],\n          \"_tags\": [],\n          \"_examples\": [],\n          \"_meta\": [],\n          \"_inner\": {\n            \"items\": [\n              {\n                \"isJoi\": true,\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {},\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              },\n              {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [\n                  {\n                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                    \"name\": \"arity\",\n                    \"arg\": 1\n                  }\n                ],\n                \"_refs\": [],\n                \"_flags\": {\n                  \"func\": true\n                },\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              }\n            ],\n            \"ordereds\": [],\n            \"inclusions\": [\n              {\n                \"isJoi\": true,\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [],\n                \"_refs\": [],\n                \"_flags\": {},\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              },\n              {\n                \"isJoi\": true,\n                \"_currentJoi\": \"[Circular ~.0.base_$key$_1_$end$_._currentJoi]\",\n                \"_type\": \"object\",\n                \"_settings\": null,\n                \"_valids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_invalids\": {\n                  \"_set\": {},\n                  \"_hasRef\": false\n                },\n                \"_tests\": [\n                  {\n                    \"func\": function (value, state, options) {\\n\\n            if (value.length === n) {\\n                return value;\\n            }\\n\\n            return this.createError('function.arity', { n }, state, options);\\n        },\n                    \"name\": \"arity\",\n                    \"arg\": 1\n                  }\n                ],\n                \"_refs\": [],\n                \"_flags\": {\n                  \"func\": true\n                },\n                \"_description\": null,\n                \"_unit\": null,\n                \"_notes\": [],\n                \"_tags\": [],\n                \"_examples\": [],\n                \"_meta\": [],\n                \"_inner\": {\n                  \"children\": null,\n                  \"renames\": [],\n                  \"dependencies\": [],\n                  \"patterns\": []\n                }\n              }\n            ],\n            \"exclusions\": [],\n            \"requireds\": []\n          }\n        },\n        \"version\": \"13.4.0\"\n      }\n    }\n  }\n]\n\u001b[31m\n[1] \"base\" must be an instance of \"Joi object\"\u001b[0m","timestamp":"2020-10-22T11:46:28.530Z"}
